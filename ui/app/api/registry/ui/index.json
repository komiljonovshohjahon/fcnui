[
  {
    "name": "fcnui_theme",
    "version": "0.0.1",
    "content": "import 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nabstract class FcnuiDefaultSizes {\n  static const double borderRadius = 16.0;\n  static const double paddingVertical = 16.0;\n  static const double paddingHorizontal = 16.0;\n  static const double borderWidth = 1.0;\n  static const double selectedBorderWidth = 2.0;\n  static const double iconSize = 16.0;\n\n  static const itemSpacing = 4.0;\n}\n\nclass FcnuiDefaultColor {\n  final BuildContext context;\n\n  FcnuiDefaultColor(this.context);\n\n  ThemeData get theme {\n    final ThemeVm themeVm = ThemeVm.fromStore(fcnStore, context);\n    return themeVm.theme;\n  }\n\n  Color get borderColor => theme.dividerColor.withOpacity(.4);\n\n  Color get errorColor => Colors.red;\n\n  Color get greyColor => theme.colorScheme.onSurface.withOpacity(.5);\n}\n\nabstract class DecorationImpl {\n  final ThemeVm themeVm;\n\n  ColorImpl? color;\n  BorderImpl? border;\n  SizeImpl? size;\n  StateImpl? state;\n  ActionImpl? action;\n  ChildImpl? child;\n  ValueImpl? value;\n\n  DecorationImpl(\n    this.themeVm, {\n    this.color,\n    this.border,\n    this.size,\n    this.state,\n    this.action,\n    this.child,\n    this.value,\n  });\n\n  ThemeData get theme => themeVm.theme;\n}\n\n/// Color type of states\n///\n/// ex: background, primary, secondary, etc\nabstract class ColorImpl {\n  final ThemeVm themeVm;\n\n  ColorImpl(this.themeVm);\n\n  ThemeData get theme => themeVm.theme;\n\n  Color get primary => theme.colorScheme.primary;\n\n  Color get secondary => theme.colorScheme.secondary;\n\n  Color get tertiary => theme.colorScheme.tertiary;\n\n  Color get surface => theme.colorScheme.surface;\n\n  Color get error => Colors.red;\n\n  Color get onPrimary => theme.colorScheme.onPrimary;\n\n  Color get onSecondary => theme.colorScheme.onSecondary;\n\n  Color get onTertiary => theme.colorScheme.onTertiary;\n\n  Color get onBackground => theme.colorScheme.onBackground;\n\n  Color get onSurface => theme.colorScheme.onSurface;\n}\n\n/// Border type of states\n///\n/// ex: border, borderRadius, etc\nabstract class BorderImpl {\n  final ThemeVm themeVm;\n\n  BorderSide? borderSide;\n\n  BorderRadius? borderRadius;\n\n  BorderImpl(this.themeVm, {this.borderSide, this.borderRadius});\n\n  ThemeData get theme => themeVm.theme;\n}\n\n/// Size type of states\n///\n/// ex: padding, margin, etc\nabstract class SizeImpl {\n  final ThemeVm themeVm;\n\n  SizeImpl(this.themeVm);\n\n  ThemeData get theme => themeVm.theme;\n}\n\n/// Boolean type of states\n///\n/// ex: isDisabled, isLoading, etc\nabstract class StateImpl {\n  final ThemeVm themeVm;\n\n  final bool isDisabled;\n  final bool isLoading;\n\n  StateImpl(this.themeVm, {this.isLoading = false, this.isDisabled = false});\n\n  ThemeData get theme => themeVm.theme;\n}\n\n/// Action type of states\n///\n/// ex: onPressed, onLongPressed, etc\nabstract class ActionImpl<T> {\n  final ThemeVm themeVm;\n\n  final VoidCallback? onPressed;\n\n  final ValueChanged<T>? onValueChanged;\n\n  ActionImpl(this.themeVm, {this.onPressed, this.onValueChanged});\n\n  ThemeData get theme => themeVm.theme;\n}\n\n/// Child related theme\n///\n/// ex: child, icon, etc\nabstract class ChildImpl {\n  final ThemeVm themeVm;\n\n  Widget? child;\n\n  ChildImpl(this.themeVm, {this.child});\n\n  ThemeData get theme => themeVm.theme;\n}\n\n/// Value related\n///\n/// initialValue, validator, etc\nabstract class ValueImpl {\n  final ThemeVm themeVm;\n\n  ValueImpl(this.themeVm);\n\n  ThemeData get theme => themeVm.theme;\n}\n"
  },
  {
    "name": "button",
    "version": "0.0.1",
    "dependencies": [
      "fcnui_theme"
    ],
    "content": "//v0.0.1\n\nimport 'package:flutter/material.dart';\nimport 'package:fcnui_base/fcnui_base.dart';\n\nimport 'fcnui_theme.dart';\n\nclass ButtonDecoration extends DecorationImpl {\n  final ButtonType type;\n\n  ButtonDecoration(\n    super.themeVm, {\n    required this.type,\n    ButtonColor? color,\n    ButtonChild? child,\n    ButtonAction? action,\n    ButtonState? state,\n    ButtonSize? size,\n    ButtonBorder? border,\n  }) : super(color: color) {\n    super.color = color ??= ButtonColor(themeVm, type: type);\n    super.child = child ?? ButtonChild(themeVm);\n    super.action = action ?? ButtonAction(themeVm);\n    super.state = state ?? ButtonState(themeVm);\n    super.size = size ?? ButtonSize(themeVm, type);\n    super.border = border ?? ButtonBorder(themeVm, type);\n\n    assert(\n        this.size.iconSize >= 0, \"iconSize must be greater than or equal to 0\");\n    assert(\n        this.child.text != null ||\n            this.child.child != null ||\n            this.child.icon != null,\n        \"text, child, or icon must be provided\");\n  }\n\n  @override\n  ButtonColor get color => super.color as ButtonColor;\n\n  @override\n  ButtonChild get child => super.child as ButtonChild;\n\n  @override\n  ButtonAction get action => super.action as ButtonAction;\n\n  @override\n  ButtonState get state => super.state as ButtonState;\n\n  @override\n  ButtonSize get size => super.size as ButtonSize;\n\n  @override\n  ButtonBorder get border => super.border as ButtonBorder;\n}\n\nclass ButtonColor extends ColorImpl {\n  final ButtonType type;\n\n  ButtonColor(\n    super.theme, {\n    required this.type,\n    Color? background,\n    Color? foreground,\n    Color? disabledBackground,\n    Color? disabledForeground,\n    Color? hoverColor,\n    Color? highlightColor,\n    Color? focusColor,\n  }) {\n    void setBackground() {\n      if (background == null) this.background = background;\n      switch (type) {\n        case ButtonType.primary:\n          this.background = primary;\n        case ButtonType.secondary:\n          this.background = secondary;\n        case ButtonType.tertiary:\n          this.background = tertiary;\n        case ButtonType.error:\n          this.background = theme.colorScheme.error;\n        default:\n          return;\n      }\n    }\n\n    void setForeground() {\n      if (foreground != null) this.foreground = foreground;\n      switch (type) {\n        case ButtonType.primary:\n        case ButtonType.error:\n          this.foreground = onPrimary;\n        case ButtonType.secondary:\n          this.foreground = onSecondary;\n        case ButtonType.tertiary:\n          this.foreground = onTertiary;\n        case ButtonType.outline:\n        case ButtonType.ghost:\n          this.foreground = onSurface;\n        default:\n          return;\n      }\n    }\n\n    void setDisabledBackground() {\n      this.disabledBackground =\n          disabledBackground ?? background?.withOpacity(0.5);\n    }\n\n    void setDisabledForeground() {\n      this.disabledForeground =\n          disabledForeground ?? foreground?.withOpacity(0.5);\n    }\n\n    void setHoverColor() {\n      this.hoverColor =\n          hoverColor ?? theme.colorScheme.primary.withOpacity(0.1);\n    }\n\n    void setHighlightColor() {\n      this.highlightColor =\n          highlightColor ?? theme.colorScheme.primary.withOpacity(0.2);\n    }\n\n    void setFocusColor() {\n      this.focusColor = focusColor ?? this.highlightColor;\n    }\n\n    setBackground();\n    setForeground();\n    setDisabledBackground();\n    setDisabledForeground();\n    setHoverColor();\n    setHighlightColor();\n    setFocusColor();\n  }\n\n  Color? background;\n\n  Color? foreground;\n\n  Color? disabledBackground;\n\n  Color? disabledForeground;\n\n  Color? hoverColor;\n\n  Color? highlightColor;\n\n  Color? focusColor;\n}\n\nclass ButtonAction extends ActionImpl {\n  /// If [onPressed] is null, the button will be disabled\n  ButtonAction(super.themeVm, {super.onPressed});\n\n  bool get isDisabled => onPressed == null;\n}\n\nclass ButtonChild extends ChildImpl {\n  final String? text;\n\n  final IconData? icon;\n\n  /// If [child] is provided, [text] will be ignored\n  ///\n  /// [child] will be used as the button's child\n  ///\n  /// Icon of the button\n  ///\n  /// If [isLoading] is true, icon will be replaced with loading indicator\n  ButtonChild(super.themeVm, {super.child, this.text, this.icon});\n}\n\nclass ButtonState extends StateImpl {\n  /// If true, it will show a loading indicator\n  ///\n  /// If [icon] is provided, icon will be replaced with loading indicator\n  ///\n  /// [onPressed] will be disabled if [isLoading] is true\n  ButtonState(super.themeVm, {super.isLoading});\n}\n\nclass ButtonSize extends SizeImpl {\n  final ButtonType type;\n\n  final double iconSize;\n\n  final Size? minimumSize;\n\n  late final TextStyle textStyle;\n\n  late final EdgeInsetsGeometry padding;\n\n  /// Size of the icon\n  ///\n  /// Default is 18px\n  ///\n  /// Minimum size of the button\n  ///\n  /// Default is 88px x 40px\n  ///\n  /// Text style of the button\n  ///\n  /// Default is bodyMedium\n  ButtonSize(super.themeVm, this.type,\n      {this.iconSize = 18,\n      this.minimumSize,\n      TextStyle? textStyle,\n      EdgeInsetsGeometry? padding}) {\n    void setTextStyle() {\n      this.textStyle = textStyle ?? theme.textTheme.bodyMedium!.sp;\n    }\n\n    void setPadding() {\n      this.padding =\n          padding ?? const EdgeInsets.symmetric(horizontal: 16, vertical: 8).w;\n    }\n\n    setTextStyle();\n    setPadding();\n  }\n}\n\nclass ButtonBorder extends BorderImpl {\n  final ButtonType type;\n\n  ButtonBorder(super.themeVm, this.type,\n      {BorderSide? borderSide, BorderRadius? borderRadius}) {\n    void setBorderSide() {\n      this.borderSide = borderSide ??\n          BorderSide(color: theme.dividerColor.withOpacity(0.6)).w;\n    }\n\n    void setBorderRadius() {\n      this.borderRadius = borderRadius ?? BorderRadius.circular(6).r;\n    }\n\n    setBorderSide();\n    setBorderRadius();\n  }\n}\n\ntypedef ButtonDecorationBuilder = ButtonDecoration Function(\n    ThemeVm themeVm, ButtonType type);\n\nenum ButtonType {\n  primary,\n  secondary,\n  tertiary,\n  error,\n  outline,\n  ghost,\n  icon,\n}\n\nclass DefaultButton extends StatelessWidget {\n  final ButtonType type;\n  final ButtonDecorationBuilder? decorationBuilder;\n\n  const DefaultButton(\n      {super.key, this.decorationBuilder, this.type = ButtonType.primary});\n\n  @override\n  Widget build(BuildContext context) {\n    return ThemeProvider(builder: (context, themeVm) {\n      final ButtonDecoration decorationTheme =\n          decorationBuilder?.call(themeVm, type) ??\n              ButtonDecoration(themeVm, type: type);\n      return getChild(decorationTheme);\n    });\n  }\n\n  Widget getChild(ButtonDecoration decoration) {\n    final vm = decoration.themeVm;\n    return Theme(\n        data: vm.theme.copyWith(\n          elevatedButtonTheme: ElevatedButtonThemeData(\n            style: _getButtonStyle(decoration),\n          ),\n          textButtonTheme: TextButtonThemeData(\n            style: _getButtonStyle(decoration),\n          ),\n          iconButtonTheme: IconButtonThemeData(\n            style: _getButtonStyle(decoration),\n          ),\n        ),\n        child: _getButtonWidgetType(decoration));\n  }\n\n  ButtonStyle _getIconButtonStyle(ButtonDecoration decoration) {\n    return IconButton.styleFrom(\n      minimumSize: decoration.size.minimumSize?.w,\n      disabledMouseCursor: SystemMouseCursors.forbidden,\n      backgroundColor: decoration.color.background,\n      foregroundColor: decoration.color.foreground,\n      hoverColor: decoration.color.hoverColor,\n      disabledBackgroundColor: decoration.color.disabledBackground,\n      disabledForegroundColor: decoration.color.disabledForeground,\n      highlightColor: decoration.color.highlightColor,\n      focusColor: decoration.color.focusColor,\n      padding: decoration.size.padding,\n      splashFactory: NoSplash.splashFactory,\n    );\n  }\n\n  ButtonStyle _getButtonStyle(ButtonDecoration decoration) {\n    if (type == ButtonType.icon) {\n      return _getIconButtonStyle(decoration);\n    }\n    return ElevatedButton.styleFrom(\n      disabledBackgroundColor: decoration.color.disabledBackground,\n      disabledForegroundColor: decoration.color.disabledForeground,\n      backgroundColor: decoration.color.background,\n      foregroundColor: decoration.color.foreground,\n      shape: _getShape(decoration),\n      side: _getBorder(decoration),\n      padding: decoration.size.padding,\n      minimumSize: decoration.size.minimumSize?.w,\n      splashFactory: NoSplash.splashFactory,\n      disabledMouseCursor: SystemMouseCursors.forbidden,\n      textStyle: _getTextStyle(decoration),\n    );\n  }\n\n  TextStyle _getTextStyle(ButtonDecoration decoration) {\n    return decoration.size.textStyle;\n  }\n\n  Widget _getButtonWidgetType(ButtonDecoration decoration) {\n    bool isDisabled = decoration.action.isDisabled;\n\n    switch (type) {\n      case ButtonType.primary:\n      case ButtonType.secondary:\n      case ButtonType.tertiary:\n      case ButtonType.error:\n        if (decoration.child.icon == null) {\n          return ElevatedButton(\n            onPressed: isDisabled ? null : decoration.action.onPressed,\n            child: _getButtonChild(decoration),\n          );\n        } else {\n          if (decoration.child.text != null &&\n              decoration.child.text!.isNotEmpty) {\n            return ElevatedButton.icon(\n              onPressed: isDisabled ? null : decoration.action.onPressed,\n              label: _getButtonChild(decoration),\n              icon: decoration.state.isLoading\n                  ? const _LoadingIndicator()\n                  : Icon(decoration.child.icon,\n                      size: decoration.size.iconSize.w),\n            );\n          }\n          return ElevatedButton(\n            onPressed: isDisabled ? null : decoration.action.onPressed,\n            child: decoration.state.isLoading\n                ? const _LoadingIndicator()\n                : Icon(decoration.child.icon, size: decoration.size.iconSize.w),\n          );\n        }\n      case ButtonType.outline:\n      case ButtonType.ghost:\n        if (decoration.child.icon == null) {\n          return TextButton(\n            onPressed: isDisabled ? null : decoration.action.onPressed,\n            child: _getButtonChild(decoration),\n          );\n        } else {\n          return TextButton.icon(\n            onPressed: isDisabled ? null : decoration.action.onPressed,\n            label: _getButtonChild(decoration),\n            icon: decoration.state.isLoading\n                ? const _LoadingIndicator()\n                : Icon(decoration.child.icon, size: decoration.size.iconSize.w),\n          );\n        }\n      case ButtonType.icon:\n        return IconButton(\n          onPressed: isDisabled ? null : decoration.action.onPressed,\n          icon: Icon(decoration.child.icon, size: decoration.size.iconSize),\n        );\n      default:\n        return const SizedBox();\n    }\n  }\n\n  Widget _getButtonChild(ButtonDecoration decoration) {\n    final ch = decoration.child.child ?? Text(_getText(decoration));\n    if (decoration.child.icon == null) {\n      if (decoration.state.isLoading) {\n        return Row(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            const _LoadingIndicator(),\n            ch,\n          ],\n        ).spaced(8);\n      }\n    }\n    return ch;\n  }\n\n  String _getText(ButtonDecoration decoration) {\n    return decoration.child.text ?? 'Button';\n  }\n\n  BorderSide? _getBorder(ButtonDecoration decoration) {\n    if (type == ButtonType.ghost) return BorderSide.none;\n    return decoration.border.borderSide;\n  }\n\n  OutlinedBorder? _getShape(ButtonDecoration decoration) {\n    return RoundedRectangleBorder(\n      borderRadius: decoration.border.borderRadius!,\n    );\n  }\n}\n\nclass _LoadingIndicator extends StatelessWidget {\n  const _LoadingIndicator();\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox(\n      width: 20.w,\n      height: 20.h,\n      child: CircularProgressIndicator(strokeWidth: 2.w),\n    );\n  }\n}\n"
  },
  {
    "name": "card",
    "version": "0.0.1",
    "dependencies": [
      "fcnui_theme"
    ],
    "content": "//v0.0.1\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nimport 'fcnui_theme.dart';\n\nclass CardDecoration extends DecorationImpl {\n  CardDecoration(\n    super.themeVm, {\n    required CardChild child,\n    CardColor? color,\n    CardBorder? border,\n    CardSize? size,\n  }) {\n    super.child = child;\n    super.color = color ?? CardColor(themeVm);\n    super.border = border ?? CardBorder(themeVm);\n    super.size = size ?? CardSize(themeVm);\n  }\n\n  @override\n  CardChild get child => super.child as CardChild;\n\n  @override\n  CardColor get color => super.color as CardColor;\n\n  @override\n  CardBorder get border => super.border as CardBorder;\n\n  @override\n  CardSize get size => super.size as CardSize;\n}\n\nclass CardChild extends ChildImpl {\n  CardTitle? title;\n  CardSubtitle? subtitle;\n  CardContent? content;\n  CardFooter? footer;\n\n  CardCustom? custom;\n\n  CardChild(super.themeVm,\n      {CardTitle? title,\n      CardSubtitle? subtitle,\n      CardContent? content,\n      CardFooter? footer,\n      CardCustom? custom})\n      :\n        //assert if custom is null, then title, content, and footer cannot be null\n        assert(\n            custom == null\n                ? title != null && content != null && footer != null\n                : true,\n            'CardChild: custom cannot be null if title, content, and footer are null') {\n    final bool isCustom = custom != null;\n    if (isCustom) {\n      this.custom = custom;\n    } else {\n      this.title = title!.copyWith(\n          style: title.style ??\n              theme.textTheme.headlineSmall!\n                  .copyWith(fontWeight: FontWeight.bold));\n\n      this.subtitle = subtitle!.copyWith(\n          style: subtitle.style ??\n              theme.textTheme.labelLarge!.copyWith(\n                  fontWeight: FontWeight.normal,\n                  color: theme.colorScheme.onSurface.withOpacity(0.6)));\n\n      this.content = content;\n      this.footer = footer;\n    }\n  }\n}\n\nclass CardColor extends ColorImpl {\n  CardColor(\n    super.themeVm, {\n    Color? background,\n    List<BoxShadow>? boxShadow,\n  }) {\n    void setBackground() {\n      this.background = background ?? theme.colorScheme.surface;\n    }\n\n    void setBoxShadow() {\n      this.boxShadow = boxShadow ??\n          [\n            BoxShadow(\n              offset: const Offset(0, 2).w,\n              blurRadius: 4.r,\n              spreadRadius: 0,\n              color: Colors.black.withOpacity(0.08),\n            ),\n            BoxShadow(\n              offset: const Offset(0, 3).w,\n              blurRadius: 10.r,\n              spreadRadius: 0,\n              color: Colors.black.withOpacity(0.1),\n            )\n          ];\n    }\n\n    setBackground();\n    setBoxShadow();\n  }\n\n  Color? background;\n  List<BoxShadow>? boxShadow;\n}\n\nclass CardSize extends SizeImpl {\n  EdgeInsetsGeometry? padding;\n  CrossAxisAlignment? childrenCrossAxisAlignment;\n\n  CardSize(\n    super.themeVm, {\n    EdgeInsetsGeometry? padding,\n    CrossAxisAlignment? childrenCrossAxisAlignment,\n  }) {\n    this.padding = padding ?? const EdgeInsets.all(24).w;\n    this.childrenCrossAxisAlignment =\n        childrenCrossAxisAlignment ?? CrossAxisAlignment.start;\n  }\n}\n\nclass CardBorder extends BorderImpl {\n  CardBorder(\n    super.themeVm, {\n    BorderSide? borderSide,\n    BorderRadius? borderRadius,\n  }) {\n    super.borderSide = borderSide ??\n        BorderSide(\n            color: theme.colorScheme.onSurface.withOpacity(0.1),\n            strokeAlign: BorderSide.strokeAlignInside);\n    super.borderRadius =\n        borderRadius ?? const BorderRadius.all(Radius.circular(8)).r;\n  }\n}\n\nclass CardTitle {\n  final String title;\n\n  /// If [style] is null, it will use the default style\n  final TextStyle? style;\n\n  const CardTitle({\n    required this.title,\n    this.style,\n  });\n\n  //copyWith\n  CardTitle copyWith({\n    String? title,\n    TextStyle? style,\n  }) {\n    return CardTitle(\n      title: title ?? this.title,\n      style: style ?? this.style,\n    );\n  }\n}\n\nclass CardSubtitle {\n  final String subtitle;\n\n  /// If [style] is null, it will use the default style\n  final TextStyle? style;\n\n  const CardSubtitle({\n    required this.subtitle,\n    this.style,\n  });\n\n  //copyWith\n  CardSubtitle copyWith({\n    String? subtitle,\n    TextStyle? style,\n  }) {\n    return CardSubtitle(\n      subtitle: subtitle ?? this.subtitle,\n      style: style ?? this.style,\n    );\n  }\n}\n\nclass CardContent {\n  final Widget content;\n\n  const CardContent({\n    required this.content,\n  });\n\n  //copyWith\n  CardContent copyWith({\n    Widget? content,\n  }) {\n    return CardContent(\n      content: content ?? this.content,\n    );\n  }\n}\n\nclass CardFooter {\n  final List<Widget> footer;\n\n  final MainAxisAlignment mainAxisAlignment;\n\n  final Axis direction;\n\n  const CardFooter({\n    required this.footer,\n    this.mainAxisAlignment = MainAxisAlignment.spaceBetween,\n    this.direction = Axis.horizontal,\n  });\n\n  //copyWith\n  CardFooter copyWith({\n    List<Widget>? footer,\n    MainAxisAlignment? mainAxisAlignment,\n    Axis? direction,\n  }) {\n    return CardFooter(\n      footer: footer ?? this.footer,\n      mainAxisAlignment: mainAxisAlignment ?? this.mainAxisAlignment,\n      direction: direction ?? this.direction,\n    );\n  }\n}\n\nclass CardCustom {\n  final Widget widget;\n\n  const CardCustom({\n    required this.widget,\n  });\n}\n\ntypedef CardDecorationBuilder = CardDecoration Function(ThemeVm themeVm);\n\nclass DefaultCard extends StatelessWidget {\n  final CardDecorationBuilder decorationBuilder;\n\n  const DefaultCard({\n    super.key,\n    required this.decorationBuilder,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return ThemeProvider(builder: (context, themeVm) {\n      final decoration = decorationBuilder(themeVm);\n      return getChild(decoration);\n    });\n  }\n\n  Widget getChild(CardDecoration decoration) {\n    return _getCard(decoration);\n  }\n\n  Widget _getCard(CardDecoration decoration) {\n    return Container(\n        decoration: BoxDecoration(\n          color: decoration.color.background,\n          borderRadius: decoration.border.borderRadius,\n          boxShadow: decoration.color.boxShadow,\n          border: decoration.border.borderSide != null\n              ? Border.fromBorderSide(decoration.border.borderSide!)\n              : null,\n        ),\n        padding: decoration.size.padding,\n        child: decoration.child.custom == null\n            ? Column(\n                mainAxisSize: MainAxisSize.min,\n                crossAxisAlignment: decoration.size.childrenCrossAxisAlignment!,\n                children: [\n                  _getTitle(decoration),\n                  if (decoration.child.subtitle != null)\n                    _getSubtitle(decoration),\n                  _getContent(decoration),\n                  _getFooter(decoration),\n                ],\n              )\n            : Padding(\n                padding: decoration.size.padding!,\n                child: decoration.child.custom!.widget,\n              ));\n  }\n\n  Widget _getTitle(CardDecoration decoration) {\n    final title = decoration.child.title!;\n    return Text(title.title, style: decoration.child.title!.style);\n  }\n\n  Widget _getSubtitle(CardDecoration decoration) {\n    final subtitle = decoration.child.subtitle!;\n\n    Widget widget = Text(subtitle.subtitle, style: subtitle.style);\n\n    return Padding(\n      padding: EdgeInsets.only(top: 12.h),\n      child: widget,\n    );\n  }\n\n  Widget _getContent(CardDecoration decoration) {\n    final content = decoration.child.content!;\n\n    Widget widget = content.content;\n\n    return Padding(\n      padding: EdgeInsets.only(top: 22.h),\n      child: widget,\n    );\n  }\n\n  Widget _getFooter(CardDecoration decoration) {\n    final footer = decoration.child.footer!;\n\n    Widget widget = Row(\n      mainAxisAlignment: footer.mainAxisAlignment,\n      children: footer.footer.length == 1\n          ? [Expanded(child: footer.footer.first)]\n          : footer.footer,\n    );\n\n    return Padding(\n      padding: EdgeInsets.only(top: 22.h),\n      child: widget,\n    );\n  }\n}\n"
  },
  {
    "name": "checkbox",
    "version": "0.0.1",
    "dependencies": [
      "disabled",
      "dp_item"
    ],
    "content": "//v0.0.1\n\nimport 'dart:developer';\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nimport 'fcnui_theme.dart';\nimport 'disabled.dart';\nimport 'dp_item.dart';\n\nclass CheckboxDecoration extends DecorationImpl {\n  CheckboxDecoration(\n    super.themeVm, {\n    required CheckboxValue value,\n    CheckboxAction? action,\n    CheckboxState? state,\n    CheckboxChild? child,\n    CheckboxColor? color,\n    CheckboxBorder? border,\n  }) {\n    this.value = value;\n    this.action = action ?? CheckboxAction(themeVm);\n    this.state = state ?? CheckboxState(themeVm);\n    this.child = child ?? CheckboxChild(themeVm);\n    this.color = color ?? CheckboxColor(themeVm);\n    this.border = border ?? CheckboxBorder(themeVm);\n  }\n\n  @override\n  CheckboxValue get value => super.value as CheckboxValue;\n\n  @override\n  CheckboxAction get action => super.action as CheckboxAction;\n\n  @override\n  CheckboxState get state => super.state as CheckboxState;\n\n  @override\n  CheckboxChild get child => super.child as CheckboxChild;\n\n  @override\n  CheckboxColor get color => super.color as CheckboxColor;\n\n  @override\n  CheckboxBorder get border => super.border as CheckboxBorder;\n}\n\nclass CheckboxValue extends ValueImpl {\n  CheckboxValue(\n    super.themeVm, {\n    required this.items,\n    required this.name,\n    this.initialValues,\n    this.disabledItems = const [],\n    this.validator,\n    this.autovalidateMode = AutovalidateMode.onUserInteraction,\n  });\n\n  final String name;\n  final List<DpItem> items;\n  final List<String>? initialValues;\n  final List<String> disabledItems;\n  final String? Function(List<String>?)? validator;\n  final AutovalidateMode autovalidateMode;\n}\n\nclass CheckboxAction extends ActionImpl {\n  CheckboxAction(super.themeVm, {this.onChanged});\n\n  final ValueChanged<List<String>?>? onChanged;\n}\n\nclass CheckboxState extends StateImpl {\n  CheckboxState(super.themeVm, {super.isDisabled = false});\n}\n\nclass CheckboxChild extends ChildImpl {\n  CheckboxChild(\n    super.themeVm, {\n    this.title,\n    this.subtitle,\n    this.helperText,\n    this.orientation,\n    this.wrapDirection,\n    TextStyle? titleStyle,\n    TextStyle? subtitleStyle,\n    TextStyle? helperTextStyle,\n    TextStyle? errorTextStyle,\n    TextStyle? itemTitleStyle,\n    TextStyle? itemSubtitleStyle,\n  }) {\n    void setTextStyles() {\n      this.titleStyle = titleStyle ?? theme.textTheme.titleMedium;\n      this.subtitleStyle = subtitleStyle ??\n          theme.textTheme.bodySmall!\n              .copyWith(color: theme.colorScheme.onSurface.withOpacity(0.6));\n      this.helperTextStyle = helperTextStyle ?? theme.textTheme.bodyMedium;\n      this.errorTextStyle = errorTextStyle ??\n          theme.textTheme.bodyMedium!.copyWith(color: Colors.red);\n      this.itemTitleStyle = itemTitleStyle ?? theme.textTheme.bodyMedium;\n      this.itemSubtitleStyle = itemSubtitleStyle ??\n          theme.textTheme.bodySmall!\n              .copyWith(color: theme.colorScheme.onSurface.withOpacity(0.6));\n    }\n\n    setTextStyles();\n  }\n\n  final String? title;\n  final String? subtitle;\n  final String? helperText;\n\n  final OptionsOrientation? orientation;\n  final Axis? wrapDirection;\n\n  TextStyle? titleStyle;\n  TextStyle? subtitleStyle;\n  TextStyle? helperTextStyle;\n  TextStyle? errorTextStyle;\n\n  TextStyle? itemTitleStyle;\n  TextStyle? itemSubtitleStyle;\n}\n\nclass CheckboxColor extends ColorImpl {\n  CheckboxColor(super.themeVm,\n      {this.activeColor,\n      this.checkColor,\n      Color? overlayColor,\n      Color? errorColor}) {\n    void setColor() {\n      this.overlayColor = overlayColor ?? Colors.transparent;\n      this.errorColor = errorColor ?? Colors.red;\n    }\n\n    setColor();\n  }\n\n  final Color? activeColor;\n  final Color? checkColor;\n  Color? overlayColor;\n  Color? errorColor;\n}\n\nclass CheckboxBorder extends BorderImpl {\n  CheckboxBorder(super.themeVm, {super.borderSide, super.borderRadius}) {\n    void setBorder() {\n      super.borderSide = super.borderSide ??\n          BorderSide(color: theme.colorScheme.onSurface, width: 1).w;\n      super.borderRadius = super.borderRadius ?? BorderRadius.circular(4).r;\n    }\n\n    setBorder();\n  }\n}\n\ntypedef CheckboxDecorationBuilder = CheckboxDecoration Function(\n    ThemeVm themeVm);\n\nclass DefaultCheckbox extends StatelessWidget {\n  final CheckboxDecorationBuilder decorationBuilder;\n\n  const DefaultCheckbox({super.key, required this.decorationBuilder});\n\n  @override\n  Widget build(BuildContext context) {\n    return ThemeProvider(builder: (context, themeVm) {\n      final decoration = decorationBuilder(themeVm);\n      return _getChild(decoration);\n    });\n  }\n\n  Widget _getChild(CheckboxDecoration decoration) {\n    return DefaultDisabled(\n        decorationBuilder: (themeVm) => DisabledDecoration(themeVm,\n            state:\n                DisabledState(themeVm, isDisabled: decoration.state.isDisabled),\n            child: DisabledChild(themeVm,\n                child: Theme(\n                    data: decoration.theme\n                        .copyWith(checkboxTheme: _getCheckboxTheme(decoration)),\n                    child: FormBuilderField<List<String>>(\n                        name: decoration.value.name,\n                        enabled: !decoration.state.isDisabled,\n                        validator: decoration.value.validator,\n                        onChanged: decoration.action.onChanged,\n                        initialValue: decoration.value.initialValues,\n                        autovalidateMode: decoration.value.autovalidateMode,\n                        builder: (field) {\n                          return Column(\n                              mainAxisSize: MainAxisSize.min,\n                              crossAxisAlignment: CrossAxisAlignment.start,\n                              children: [\n                                if (decoration.child.title != null)\n                                  Text(decoration.child.title!,\n                                      style:\n                                          decoration.child.titleStyle!.copyWith(\n                                        color: field.errorText == null\n                                            ? null\n                                            : decoration.color.errorColor,\n                                      )),\n                                if (decoration.child.subtitle != null)\n                                  Text(decoration.child.subtitle!,\n                                      style: decoration.child.subtitleStyle!),\n                                if (decoration.child.title != null ||\n                                    decoration.child.subtitle != null)\n                                  const SizedBox(height: 4),\n                                GroupCheckbox(\n                                    field: field, decoration: decoration),\n                                if (decoration.child.helperText != null)\n                                  Text(decoration.child.helperText!,\n                                      style: decoration.child.helperTextStyle!),\n                                if (field.errorText != null)\n                                  Text(field.errorText!,\n                                      style: decoration.child.errorTextStyle!)\n                              ]).spaced(4);\n                        })))));\n  }\n\n  CheckboxThemeData _getCheckboxTheme(CheckboxDecoration decoration) {\n    return decoration.theme.checkboxTheme.copyWith(\n        side: decoration.border.borderSide,\n        shape: RoundedRectangleBorder(\n            borderRadius: decoration.border.borderRadius!),\n        overlayColor: MaterialStatePropertyAll(decoration.color.overlayColor),\n        splashRadius: 0);\n  }\n}\n\nclass GroupCheckbox extends StatelessWidget {\n  final FormFieldState<List<String>> field;\n  final CheckboxDecoration decoration;\n\n  const GroupCheckbox(\n      {super.key, required this.field, required this.decoration});\n\n  @override\n  Widget build(BuildContext context) {\n    if (decoration.child.orientation == OptionsOrientation.horizontal) {\n      return Row(\n        mainAxisSize: MainAxisSize.min,\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          for (final item in decoration.value.items)\n            CustomCheckbox(\n              field: field,\n              item: item,\n              decoration: decoration,\n            ),\n        ],\n      );\n    } else if (decoration.child.orientation == OptionsOrientation.vertical) {\n      return Column(\n        mainAxisSize: MainAxisSize.min,\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          for (final item in decoration.value.items)\n            CustomCheckbox(\n              field: field,\n              item: item,\n              decoration: decoration,\n            ),\n        ],\n      );\n    }\n    return Wrap(\n      spacing: 10.0,\n      runSpacing: 10.0,\n      direction: decoration.child.wrapDirection ?? Axis.horizontal,\n      children: [\n        for (final item in decoration.value.items)\n          CustomCheckbox(\n            field: field,\n            item: item,\n            decoration: decoration,\n          ),\n      ],\n    );\n  }\n}\n\nclass CustomCheckbox extends StatelessWidget {\n  final FormFieldState<List<String>> field;\n  final DpItem item;\n  final CheckboxDecoration decoration;\n\n  const CustomCheckbox(\n      {super.key,\n      required this.field,\n      required this.decoration,\n      required this.item});\n\n  @override\n  Widget build(BuildContext context) {\n    final bool isDisabled = decoration.value.disabledItems.contains(item.id);\n    final bool isValid = field.errorText == null;\n    return DefaultDisabled(\n        decorationBuilder: (context) => DisabledDecoration(context,\n            state: DisabledState(context, isDisabled: isDisabled),\n            child: DisabledChild(context,\n                child: GestureDetector(\n                    onTap: () {\n                      onCheckboxChanged(\n                          !(field.value?.contains(item.id) ?? false));\n                    },\n                    child: Row(\n                        mainAxisSize: MainAxisSize.min,\n                        crossAxisAlignment: item.subtitle != null\n                            ? CrossAxisAlignment.start\n                            : CrossAxisAlignment.center,\n                        children: [\n                          //Checkbox\n                          Checkbox(\n                              value: field.value?.contains(item.id) ??\n                                  decoration.value.initialValues\n                                      ?.contains(item.id) ??\n                                  false,\n                              onChanged: onCheckboxChanged),\n\n                          Column(\n                              mainAxisSize: MainAxisSize.min,\n                              crossAxisAlignment: CrossAxisAlignment.start,\n                              children: [\n                                //Title\n                                Text(\n                                  item.title,\n                                  style:\n                                      decoration.child.itemTitleStyle!.copyWith(\n                                    color: isValid\n                                        ? null\n                                        : (isDisabled\n                                            ? null\n                                            : decoration.color.errorColor),\n                                  ),\n                                ),\n\n                                //Subtitle, if any\n                                if (item.subtitle != null)\n                                  Text(item.subtitle!,\n                                      style: decoration.child.itemSubtitleStyle)\n                              ]).spaced(2)\n                        ]).spaced(4)))));\n  }\n\n  void onCheckboxChanged(bool? value) {\n    try {\n      if (value == true) {\n        field.didChange([...(field.value ?? []), item.id]);\n      } else {\n        field.didChange(field.value?.where((e) => e != item.id).toList() ?? []);\n      }\n      decoration.action.onChanged?.call(field.value);\n    } catch (e, st) {\n      log(e.toString());\n      log(st.toString());\n    }\n  }\n}\n"
  },
  {
    "name": "disabled",
    "version": "0.0.1",
    "dependencies": [
      "fcnui_theme"
    ],
    "content": "//v0.0.1\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nimport 'fcnui_theme.dart';\n\nclass DisabledDecoration extends DecorationImpl {\n  DisabledDecoration(\n    super.themeVm, {\n    required DisabledChild child,\n    DisabledColor? color,\n    DisabledState? state,\n  }) {\n    super.child = child;\n    super.color = color ?? DisabledColor(themeVm);\n    super.state = state ?? DisabledState(themeVm);\n  }\n\n  @override\n  DisabledChild get child => super.child as DisabledChild;\n\n  @override\n  DisabledColor get color => super.color as DisabledColor;\n\n  @override\n  DisabledState get state => super.state as DisabledState;\n}\n\nclass DisabledState extends StateImpl {\n  final bool showForbiddenCursor;\n\n  DisabledState(super.themeVm,\n      {super.isDisabled = false, this.showForbiddenCursor = true});\n}\n\nclass DisabledChild extends ChildImpl {\n  DisabledChild(super.themeVm, {required Widget child}) {\n    this.child = child;\n  }\n}\n\nclass DisabledColor extends ColorImpl {\n  DisabledColor(super.themeVm, {double? opacity}) {\n    void setOpacity() {\n      this.opacity = opacity ?? 0.5;\n    }\n\n    setOpacity();\n  }\n\n  double? opacity;\n}\n\ntypedef DisabledDecorationBuilder = DisabledDecoration Function(\n    ThemeVm themeVm);\n\nclass DefaultDisabled extends StatelessWidget {\n  final DisabledDecorationBuilder decorationBuilder;\n  const DefaultDisabled({super.key, required this.decorationBuilder});\n\n  @override\n  Widget build(BuildContext context) {\n    return ThemeProvider(builder: (context, themeVm) {\n      final DisabledDecoration decoration = decorationBuilder(themeVm);\n\n      Widget view = AbsorbPointer(\n        absorbing: decoration.state.isDisabled,\n        child: decoration.child.child,\n      );\n\n      if (decoration.state.showForbiddenCursor && decoration.state.isDisabled) {\n        view = MouseRegion(cursor: SystemMouseCursors.forbidden, child: view);\n      }\n\n      return Opacity(\n          opacity: decoration.state.isDisabled ? decoration.color.opacity! : 1,\n          child: view);\n    });\n  }\n}\n"
  },
  {
    "name": "dp_item",
    "version": "0.0.1",
    "content": "//v0.0.1\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nclass DpItem extends Equatable {\n  final String id;\n  final String title;\n  final String? subtitle;\n  final IconData? icon;\n\n  const DpItem(\n      {required this.id, required this.title, this.subtitle, this.icon});\n\n  @override\n  List<Object?> get props => [id, title, subtitle, icon];\n\n  //copyWith\n  DpItem copyWith({\n    String? id,\n    String? title,\n    String? subtitle,\n    IconData? icon,\n  }) {\n    return DpItem(\n      id: id ?? this.id,\n      title: title ?? this.title,\n      subtitle: subtitle ?? this.subtitle,\n      icon: icon ?? this.icon,\n    );\n  }\n}\n"
  },
  {
    "name": "form",
    "version": "0.0.1",
    "content": "//v0.0.1\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nabstract class IFormModel extends Equatable {\n  ///This will form the key in the form value Map\n  final String name;\n\n  const IFormModel({\n    required this.name,\n  });\n}\n\nclass FormModel {\n  /// Used for [FormBuilder] to control form\n  final GlobalKey<FormBuilderState> formKey = GlobalKey<FormBuilderState>();\n\n  /// Used for [SaveButton] to enable/disable button\n  final ValueNotifier<bool> isValidFormNotifier = ValueNotifier(false);\n\n  /// Returns true if form is valid\n  bool get isValid => formKey.currentState?.isValid ?? false;\n\n  /// Callback for onChanged event\n  ///\n  /// Triggered when any field in form is changed\n  void Function()? onChanged;\n\n  /// Returns single value from form\n  dynamic getValue(String name) => formKey.currentState?.fields[name]?.value;\n\n  /// Returns all values from form\n  Map<String, dynamic> getValues() => formKey.currentState?.value ?? {};\n\n  /// Set single value to form\n  void patchValue(Map<String, dynamic> value, {bool isSave = true}) {\n    formKey.currentState?.patchValue(value);\n    if (isSave) save();\n  }\n\n  /// Set all values to form\n  void save() => formKey.currentState?.save();\n\n  /// Reset form to initial state\n  void reset() => formKey.currentState?.reset();\n\n  /// Validate form\n  void validate(\n          {bool focusOnInvalid = true,\n          bool autoScrollWhenFocusOnInvalid = false}) =>\n      formKey.currentState?.validate(\n          autoScrollWhenFocusOnInvalid: autoScrollWhenFocusOnInvalid,\n          focusOnInvalid: focusOnInvalid);\n\n  /// Save and validate form\n  void saveAndValidate(\n          {bool focusOnInvalid = true,\n          bool autoScrollWhenFocusOnInvalid = false}) =>\n      formKey.currentState?.saveAndValidate(\n          autoScrollWhenFocusOnInvalid: autoScrollWhenFocusOnInvalid,\n          focusOnInvalid: focusOnInvalid);\n\n  /// Invalidate field\n  ///\n  /// Show error message on field if it's invalid\n  void invalidateField(String name, String message) =>\n      formKey.currentState?.fields[name]\n          ?.invalidate(message, shouldFocus: false);\n}\n\nclass DefaultForm extends StatelessWidget {\n  final FormModel vm;\n  final Widget child;\n  final bool clearValueOnUnregister;\n\n  /// If true, the form will save and validate on every change\n  ///\n  /// Used to auto validate on form change\n  ///\n  /// If using [SaveButton] trigger [autoValidate] field true.\n  final bool saveAndValidateOnChange;\n  const DefaultForm(\n      {super.key,\n      required this.vm,\n      required this.child,\n      this.saveAndValidateOnChange = false,\n      this.clearValueOnUnregister = false});\n\n  @override\n  Widget build(BuildContext context) {\n    return FormBuilder(\n      clearValueOnUnregister: clearValueOnUnregister,\n      key: vm.formKey,\n      onChanged: () {\n        if (saveAndValidateOnChange) {\n          vm.formKey.currentState?.save();\n        }\n        vm.isValidFormNotifier.value = vm.isValid;\n        vm.onChanged?.call();\n      },\n      child: child,\n    );\n  }\n}\n"
  },
  {
    "name": "input",
    "version": "0.0.1",
    "dependencies": [
      "form",
      "disabled"
    ],
    "content": "//v0.0.1\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:fcnui_base/fcnui_base.dart';\n\nimport 'fcnui_theme.dart';\nimport 'disabled.dart';\n\nclass InputDecor extends DecorationImpl {\n  InputDecor(\n    super.themeVm, {\n    required InputChild child,\n    InputState? state,\n    InputAction? action,\n    InputValue? value,\n    InputColor? color,\n    InputBorder? border,\n    InputSize? size,\n  }) {\n    super.child = child;\n    super.state = state ?? InputState(themeVm);\n    super.action = action ?? InputAction(themeVm);\n    super.value = value ?? InputValue(themeVm);\n    super.color = color ?? InputColor(themeVm);\n    super.border = border ?? InputBorder(themeVm);\n    super.size = size ?? InputSize(themeVm);\n  }\n\n  @override\n  InputChild get child => super.child as InputChild;\n\n  @override\n  InputState get state => super.state as InputState;\n\n  @override\n  InputAction get action => super.action as InputAction;\n\n  @override\n  InputValue get value => super.value as InputValue;\n\n  @override\n  InputColor get color => super.color as InputColor;\n\n  @override\n  InputBorder get border => super.border as InputBorder;\n\n  @override\n  InputSize get size => super.size as InputSize;\n}\n\nclass InputChild extends ChildImpl {\n  InputChild(\n    super.themeVm, {\n    this.helperText,\n    this.hintText,\n    this.maxLines,\n    required this.name,\n    this.inputFormatters = const [],\n    TextStyle? errorStyle,\n    TextStyle? helperStyle,\n    TextStyle? hintStyle,\n    TextStyle? valueStyle,\n  }) {\n    void setErrorStyle() {\n      this.errorStyle = errorStyle ??\n          theme.textTheme.bodyMedium!.copyWith(color: Colors.red).sp;\n    }\n\n    void setHelperStyle() {\n      this.helperStyle = helperStyle ??\n          theme.textTheme.bodyMedium!\n              .copyWith(color: theme.colorScheme.onSurface.withOpacity(0.6))\n              .sp;\n    }\n\n    void setHintStyle() {\n      this.hintStyle = hintStyle ??\n          theme.textTheme.bodyMedium!\n              .copyWith(color: theme.colorScheme.onSurface.withOpacity(0.4))\n              .sp;\n    }\n\n    void setValueStyle() {\n      this.valueStyle = valueStyle ??\n          theme.textTheme.bodyLarge!\n              .copyWith(\n                  color: theme.colorScheme.onSurface,\n                  fontWeight: FontWeight.normal)\n              .sp;\n    }\n\n    setErrorStyle();\n    setHelperStyle();\n    setHintStyle();\n    setValueStyle();\n  }\n\n  final String name;\n  final String? hintText;\n  final String? helperText;\n  final int? maxLines;\n  final List<TextInputFormatter> inputFormatters;\n\n  TextStyle? errorStyle;\n  TextStyle? helperStyle;\n  TextStyle? hintStyle;\n  TextStyle? valueStyle;\n}\n\nclass InputState extends StateImpl {\n  InputState(\n    super.themeVm, {\n    super.isDisabled,\n    this.readOnly = false,\n    this.focusNode,\n    this.isFilled = true,\n  });\n\n  final bool readOnly;\n  final FocusNode? focusNode;\n  final bool isFilled;\n}\n\nclass InputAction extends ActionImpl {\n  InputAction(super.themeVm, {this.onChanged});\n\n  final ValueChanged<String?>? onChanged;\n}\n\nclass InputValue extends ValueImpl {\n  InputValue(super.themeVm,\n      {this.initialValue, this.validators = const [], this.controller});\n\n  final String? initialValue;\n  final List<FormFieldValidator<String>> validators;\n  final TextEditingController? controller;\n}\n\nclass InputColor extends ColorImpl {\n  InputColor(\n    super.themeVm, {\n    Color? hoverColor,\n    Color? fillColor,\n  }) {\n    void setHoverColor() {\n      this.hoverColor = hoverColor ?? Colors.transparent;\n    }\n\n    void setFillColor() {\n      this.fillColor = fillColor ?? theme.colorScheme.surface;\n    }\n\n    setHoverColor();\n    setFillColor();\n  }\n\n  Color? hoverColor;\n  Color? fillColor;\n}\n\nclass InputBorder extends BorderImpl {\n  InputBorder(\n    super.themeVm, {\n    BorderSide? focusedBorderSide,\n    BorderSide? enabledBorderSide,\n    BorderSide? errorBorderSide,\n    BorderSide? disabledBorderSide,\n    BorderRadius? borderRadius,\n  }) {\n    void setBorderRadius() {\n      super.borderRadius = borderRadius ??\n          BorderRadius.circular(FcnuiDefaultSizes.borderRadius).r;\n    }\n\n    void setFocusBorderSide() {\n      this.focusedBorderSide = focusedBorderSide ??\n          BorderSide(\n                  color: theme.colorScheme.primary,\n                  width: FcnuiDefaultSizes.selectedBorderWidth,\n                  strokeAlign: BorderSide.strokeAlignOutside)\n              .w;\n    }\n\n    void setEnabledBorderSide() {\n      this.enabledBorderSide = enabledBorderSide ??\n          BorderSide(\n                  color: theme.dividerColor,\n                  width: FcnuiDefaultSizes.borderWidth,\n                  strokeAlign: BorderSide.strokeAlignInside)\n              .w;\n    }\n\n    void setErrorBorderSide() {\n      this.errorBorderSide = errorBorderSide ??\n          const BorderSide(\n                  color: Colors.red,\n                  width: FcnuiDefaultSizes.borderWidth,\n                  strokeAlign: BorderSide.strokeAlignInside)\n              .w;\n    }\n\n    void setDisabledBorderSide() {\n      this.disabledBorderSide = disabledBorderSide ??\n          BorderSide(\n                  width: FcnuiDefaultSizes.borderWidth,\n                  color: theme.dividerColor.withOpacity(0.6),\n                  strokeAlign: BorderSide.strokeAlignInside)\n              .w;\n    }\n\n    setBorderRadius();\n    setFocusBorderSide();\n    setEnabledBorderSide();\n    setErrorBorderSide();\n    setDisabledBorderSide();\n  }\n\n  BorderSide? focusedBorderSide;\n  BorderSide? enabledBorderSide;\n  BorderSide? errorBorderSide;\n  BorderSide? disabledBorderSide;\n}\n\nclass InputSize extends SizeImpl {\n  InputSize(\n    super.themeVm, {\n    EdgeInsetsGeometry? padding,\n  }) {\n    void setPadding() {\n      this.padding =\n          padding ?? const EdgeInsets.symmetric(horizontal: 12, vertical: 8).w;\n    }\n\n    setPadding();\n  }\n\n  EdgeInsetsGeometry? padding;\n}\n\ntypedef InputDecorBuilder = InputDecor Function(ThemeVm themeVm);\n\nclass DefaultInput extends StatelessWidget {\n  final InputDecorBuilder decorationBuilder;\n\n  const DefaultInput({super.key, required this.decorationBuilder});\n\n  @override\n  Widget build(BuildContext context) {\n    return ThemeProvider(builder: (context, themeVm) {\n      final decoration = decorationBuilder(themeVm);\n      return _getChild(decoration);\n    });\n  }\n\n  Widget _getChild(InputDecor decoration) {\n    final theme = decoration.theme;\n    return DefaultDisabled(\n        decorationBuilder: (context) => DisabledDecoration(context,\n            state:\n                DisabledState(context, isDisabled: decoration.state.isDisabled),\n            child: DisabledChild(context,\n                child: Theme(\n                    data: theme.copyWith(\n                        inputDecorationTheme: InputDecorationTheme(\n                            hoverColor: decoration.color.hoverColor,\n                            //Border when tapped and focused\n                            focusedBorder: OutlineInputBorder(\n                                borderRadius: decoration.border.borderRadius!,\n                                borderSide:\n                                    decoration.border.focusedBorderSide!),\n                            //Idle state border\n                            enabledBorder: OutlineInputBorder(\n                                borderRadius: decoration.border.borderRadius!,\n                                borderSide:\n                                    decoration.border.enabledBorderSide!),\n                            errorBorder: OutlineInputBorder(\n                                borderRadius: decoration.border.borderRadius!,\n                                borderSide: decoration.border.errorBorderSide!),\n                            disabledBorder: OutlineInputBorder(\n                                borderRadius: decoration.border.borderRadius!,\n                                borderSide:\n                                    decoration.border.disabledBorderSide!),\n                            focusedErrorBorder: OutlineInputBorder(\n                                borderRadius: decoration.border.borderRadius!,\n                                borderSide: decoration.border.errorBorderSide!),\n                            errorStyle: decoration.child.errorStyle!,\n                            helperStyle: decoration.child.helperStyle!,\n                            contentPadding: decoration.size.padding,\n                            floatingLabelBehavior: FloatingLabelBehavior.never,\n                            filled: decoration.state.isFilled,\n                            fillColor: decoration.color.fillColor,\n                            hintStyle: decoration.child.hintStyle!)),\n                    child: FormBuilderTextField(\n                        focusNode: decoration.state.focusNode,\n                        controller: decoration.value.controller,\n                        style: decoration.child.valueStyle!,\n                        name: decoration.child.name,\n                        initialValue: decoration.value.initialValue,\n                        onChanged: decoration.action.onChanged,\n                        maxLines: decoration.child.maxLines,\n                        validator: FormBuilderValidators.compose(\n                            decoration.value.validators),\n                        inputFormatters: decoration.child.inputFormatters,\n                        enabled: !decoration.state.isDisabled,\n                        readOnly: decoration.state.readOnly,\n                        decoration: InputDecoration(\n                            helperText: decoration.child.helperText,\n                            hintText: decoration.child.hintText))))));\n  }\n}\n"
  },
  {
    "name": "label",
    "version": "0.0.1",
    "dependencies": [
      "disabled"
    ],
    "content": "//v0.0.1\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nimport 'fcnui_theme.dart';\nimport 'disabled.dart';\n\nclass LabelDecoration extends DecorationImpl {\n  LabelDecoration(\n    super.themeVm, {\n    required LabelChild child,\n    LabelState? state,\n  }) {\n    this.child = child;\n    this.state = state ?? LabelState(themeVm);\n  }\n\n  @override\n  LabelChild get child => super.child as LabelChild;\n\n  @override\n  LabelState get state => super.state as LabelState;\n}\n\nclass LabelChild extends ChildImpl {\n  LabelChild(super.themeVm, {required this.text});\n  final String text;\n}\n\nclass LabelState extends StateImpl {\n  LabelState(super.themeVm, {super.isDisabled, this.isRequired = false});\n\n  final bool isRequired;\n}\n\ntypedef LabelDecorationBuilder = LabelDecoration Function(ThemeVm themeVm);\n\nclass Label extends StatelessWidget {\n  final LabelDecorationBuilder decorationBuilder;\n\n  const Label({super.key, required this.decorationBuilder});\n\n  @override\n  Widget build(BuildContext context) {\n    return ThemeProvider(builder: (context, themeVm) {\n      final decoration = decorationBuilder(themeVm);\n      return DefaultDisabled(\n          decorationBuilder: (themeVm) => DisabledDecoration(themeVm,\n              state: DisabledState(themeVm,\n                  isDisabled: decoration.state.isDisabled),\n              child: DisabledChild(themeVm,\n                  child: RichText(\n                      text: TextSpan(children: [\n                    TextSpan(\n                        text: decoration.child.text,\n                        style: decoration.themeVm.theme.textTheme.titleSmall!\n                            .copyWith(\n                          fontWeight: FontWeight.normal,\n                          color: decoration.color!.onSurface.withOpacity(0.4),\n                        )),\n                    if (decoration.state.isRequired)\n                      TextSpan(\n                          text: \"\\t*\",\n                          style: decoration.themeVm.theme.textTheme.titleMedium!\n                              .copyWith(color: Colors.red))\n                  ])))));\n    });\n  }\n}\n"
  },
  {
    "name": "pagination",
    "version": "0.0.1",
    "dependencies": [
      "button"
    ],
    "content": "//v0.0.1\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nimport 'fcnui_theme.dart';\nimport 'button.dart';\n\nclass PaginationDecoration extends DecorationImpl {\n  PaginationDecoration(\n    super.themeVm, {\n    required PaginationAction action,\n    required PaginationValue value,\n    PaginationColor? color,\n    PaginationBorder? border,\n    PaginationSize? size,\n  }) {\n    super.action = action;\n    super.value = value;\n    super.color = color ?? PaginationColor(themeVm);\n    super.border = border ?? PaginationBorder(themeVm);\n    super.size = size ?? PaginationSize(themeVm);\n  }\n\n  @override\n  PaginationAction get action => super.action as PaginationAction;\n\n  @override\n  PaginationValue get value => super.value as PaginationValue;\n\n  @override\n  PaginationColor get color => super.color as PaginationColor;\n\n  @override\n  PaginationBorder get border => super.border as PaginationBorder;\n\n  @override\n  PaginationSize get size => super.size as PaginationSize;\n}\n\nclass PaginationValue extends ValueImpl {\n  final int totalPages;\n  final int limit;\n  final int currentPage;\n\n  /// The number of page buttons to show\n  ///\n  /// Default is 7\n  PaginationValue(\n    super.themeVm, {\n    required this.totalPages,\n    this.limit = 7,\n    this.currentPage = 1,\n  });\n}\n\nclass PaginationAction extends ActionImpl<int> {\n  PaginationAction(super.themeVm, {required ValueChanged<int> onPageChanged})\n      : super(onValueChanged: onPageChanged);\n}\n\nclass PaginationSize extends SizeImpl {\n  PaginationSize(\n    super.themeVm, {\n    EdgeInsets? padding,\n    Size? buttonMinSize,\n  }) {\n    this.padding = padding ?? const EdgeInsets.all(8).w;\n    this.buttonMinSize = buttonMinSize ?? const Size(50, 50);\n  }\n\n  EdgeInsets? padding;\n  Size? buttonMinSize;\n}\n\nclass PaginationColor extends ColorImpl {\n  PaginationColor(\n    super.themeVm, {\n    Color? backgroundColor,\n    ButtonType? selectedButtonType,\n    ButtonType? unselectedButtonType,\n    ButtonType? arrowButtonType,\n    IconData? nextButtonIcon,\n    IconData? previousButtonIcon,\n  }) {\n    this.backgroundColor =\n        backgroundColor ?? theme.dividerColor.withOpacity(.4);\n    this.selectedButtonType = selectedButtonType ?? ButtonType.primary;\n    this.unselectedButtonType = unselectedButtonType ?? ButtonType.ghost;\n    this.arrowButtonType = arrowButtonType ?? ButtonType.icon;\n    this.nextButtonIcon = nextButtonIcon ?? Icons.arrow_forward_ios;\n    this.previousButtonIcon = previousButtonIcon ?? Icons.arrow_back_ios;\n  }\n\n  Color? backgroundColor;\n  ButtonType? selectedButtonType;\n  ButtonType? unselectedButtonType;\n  ButtonType? arrowButtonType;\n  IconData? nextButtonIcon;\n  IconData? previousButtonIcon;\n}\n\nclass PaginationBorder extends BorderImpl {\n  PaginationBorder(\n    super.themeVm, {\n    BorderRadius? borderRadius,\n  }) {\n    super.borderRadius =\n        borderRadius ?? BorderRadius.circular(FcnuiDefaultSizes.borderRadius).r;\n  }\n}\n\ntypedef PaginationDecorationBuilder = PaginationDecoration Function(\n    ThemeVm themeVm);\n\nclass DefaultPagination extends StatelessWidget {\n  final PaginationDecorationBuilder decorationBuilder;\n\n  const DefaultPagination({super.key, required this.decorationBuilder});\n\n  @override\n  Widget build(BuildContext context) {\n    return ThemeProvider(builder: (context, themeVm) {\n      // If list of numbers are more than 8, then show 3 dots in the middle;\n      // If list of numbers are less than 8, then show all numbers;\n\n      final PaginationDecoration decoration = decorationBuilder(themeVm);\n\n      final currentPage = decoration.value.currentPage;\n      final totalPages = decoration.value.totalPages;\n\n      final bool isFirstPage = currentPage == 1;\n      final bool isLastPage = currentPage == totalPages;\n      return Container(\n        padding: decoration.size.padding,\n        decoration: BoxDecoration(\n          color: decoration.color.backgroundColor,\n          borderRadius: decoration.border.borderRadius,\n        ),\n        child: Row(\n          mainAxisSize: MainAxisSize.min,\n          crossAxisAlignment: CrossAxisAlignment.center,\n          children: [\n            _PreviousNextButton(\n                decoration: decoration,\n                onTap: totalPages == 1\n                    ? null\n                    : (isFirstPage ? null : () => _onPreviousPage(decoration))),\n            const SizedBox(width: 7.0).w,\n            ..._builder(decoration),\n            const SizedBox(width: 7.0).w,\n            _PreviousNextButton(\n                decoration: decoration,\n                isNext: true,\n                onTap: totalPages == 1\n                    ? null\n                    : (isLastPage ? null : () => _onNextPage(decoration))),\n          ],\n        ).spaced(2),\n      );\n    });\n  }\n\n  List<Widget> _builder(PaginationDecoration decoration) {\n    final tp = decoration.value.totalPages;\n    final cp = decoration.value.currentPage;\n    final int lim = decoration.value.limit;\n    final int currentPage = decoration.value.currentPage;\n    List<Widget> pages = [];\n\n    if (tp > lim) {\n      if (cp == 1 || cp == 2) {\n        // 1 2 ... 8\n        if (1 == currentPage) {\n          pages.add(_isSelectedBtn(decoration));\n        } else {\n          pages.add(_isUnSelectedBtn(1, decoration));\n        }\n        if (2 == currentPage) {\n          pages.add(_isSelectedBtn(decoration));\n        } else {\n          pages.add(_isUnSelectedBtn(2, decoration));\n        }\n        if (3 == currentPage) {\n          pages.add(_isSelectedBtn(decoration));\n        } else {\n          pages.add(_isUnSelectedBtn(3, decoration));\n        }\n        if (4 == currentPage) {\n          pages.add(_isSelectedBtn(decoration));\n        } else {\n          pages.add(_isUnSelectedBtn(4, decoration));\n        }\n        if (5 == currentPage) {\n          pages.add(_isSelectedBtn(decoration));\n        } else {\n          pages.add(_isUnSelectedBtn(5, decoration));\n        }\n        pages.add(_dots());\n        if (tp == currentPage) {\n          pages.add(_isSelectedBtn(decoration));\n        } else {\n          pages.add(_isUnSelectedBtn(tp, decoration));\n        }\n      } else if (cp > 2 && cp < tp - 1) {\n        // 1 ... 3 ... 8\n        if (currentPage == 1) {\n          pages.add(_isSelectedBtn(decoration));\n        } else {\n          pages.add(_isUnSelectedBtn(1, decoration));\n        }\n        if (cp == 4 && cp + 2 != currentPage) {\n          pages.add(_isUnSelectedBtn(cp - 2, decoration));\n        }\n        if (cp > 4) pages.add(_dots());\n        if (cp + 2 == currentPage) {\n          pages.add(_isSelectedBtn(decoration));\n        }\n        if (cp == (tp - 2)) {\n          pages.add(_isUnSelectedBtn(cp - 2, decoration)); //adds 6\n        }\n        if (cp - 1 == currentPage) {\n          pages.add(_isSelectedBtn(decoration));\n        } else {\n          pages.add(_isUnSelectedBtn(cp - 1, decoration));\n        }\n        if (cp == currentPage) {\n          pages.add(_isSelectedBtn(decoration));\n        } else {\n          pages.add(_isUnSelectedBtn(cp, decoration));\n        }\n        if (cp + 1 == currentPage) {\n          pages.add(_isSelectedBtn(decoration));\n        } else {\n          pages.add(_isUnSelectedBtn(cp + 1, decoration));\n        }\n        if (cp == 3 && cp + 2 != currentPage) {\n          pages.add(_isUnSelectedBtn(cp + 2, decoration));\n        }\n\n        if (cp < tp - 3) pages.add(_dots());\n\n        if (cp == tp - 3) {\n          pages.add(_isUnSelectedBtn(cp + 2, decoration));\n        }\n\n        if (tp == currentPage) {\n          pages.add(_isSelectedBtn(decoration));\n        } else {\n          pages.add(_isUnSelectedBtn(tp, decoration));\n        }\n      } else if (cp == tp - 1 || cp == tp) {\n        // 1 ... 7 8\n        if (1 == currentPage) {\n          pages.add(_isSelectedBtn(decoration));\n        } else {\n          pages.add(_isUnSelectedBtn(1, decoration));\n        }\n        pages.add(_dots());\n        if (tp - 4 == currentPage) {\n          pages.add(_isSelectedBtn(decoration));\n        } else {\n          pages.add(_isUnSelectedBtn(tp - 4, decoration));\n        }\n        if (tp - 3 == currentPage) {\n          pages.add(_isSelectedBtn(decoration));\n        } else {\n          pages.add(_isUnSelectedBtn(tp - 3, decoration));\n        }\n        if (tp - 2 == currentPage) {\n          pages.add(_isSelectedBtn(decoration));\n        } else {\n          pages.add(_isUnSelectedBtn(tp - 2, decoration));\n        }\n        if (tp - 1 == currentPage) {\n          pages.add(_isSelectedBtn(decoration));\n        } else {\n          pages.add(_isUnSelectedBtn(tp - 1, decoration));\n        }\n        if (tp == currentPage) {\n          pages.add(_isSelectedBtn(decoration));\n        } else {\n          pages.add(_isUnSelectedBtn(tp, decoration));\n        }\n      }\n    } else {\n      for (int i = 1; i <= tp; i++) {\n        if (i == currentPage) {\n          pages.add(_isSelectedBtn(decoration));\n        } else {\n          pages.add(_isUnSelectedBtn(i, decoration));\n        }\n      }\n    }\n\n    return pages;\n  }\n\n  Widget _dots() {\n    return Row(\n      mainAxisSize: MainAxisSize.min,\n      children: [\n        const SizedBox(width: 21.5).w,\n        const Text(\"...\"),\n        const SizedBox(width: 21.5).w,\n      ],\n    );\n  }\n\n  Widget _isSelectedBtn(PaginationDecoration decoration) {\n    final currentPage = decoration.value.currentPage;\n    return DefaultButton(\n      type: decoration.color.selectedButtonType!,\n      decorationBuilder: (context, type) {\n        return ButtonDecoration(\n          context,\n          type: type,\n          size: ButtonSize(context, type,\n              minimumSize: decoration.size.buttonMinSize),\n          child: ButtonChild(context, text: currentPage.toString()),\n          action: ButtonAction(context, onPressed: () {}),\n        );\n      },\n    );\n  }\n\n  Widget _isUnSelectedBtn(int i, PaginationDecoration decoration) {\n    return DefaultButton(\n      type: decoration.color.unselectedButtonType!,\n      decorationBuilder: (context, type) {\n        return ButtonDecoration(\n          context,\n          type: type,\n          size: ButtonSize(context, type,\n              minimumSize: decoration.size.buttonMinSize),\n          child: ButtonChild(context, text: i.toString()),\n          action: ButtonAction(context,\n              onPressed: () => _onNumberTap(i, decoration)),\n        );\n      },\n    );\n  }\n\n  void _onNumberTap(int i, PaginationDecoration decoration) {\n    decoration.action.onValueChanged!(i);\n  }\n\n  void _onPreviousPage(PaginationDecoration decoration) {\n    final int currentPage = decoration.value.currentPage;\n    //If currentPage is 1, then do nothing;\n    //If currentPage is > 1, then set currentPage to currentPage - 1;\n    if (currentPage == 1) {\n      return;\n    }\n    decoration.action.onValueChanged!(currentPage - 1);\n  }\n\n  void _onNextPage(PaginationDecoration decoration) {\n    final int currentPage = decoration.value.currentPage;\n    final int totalPages = decoration.value.totalPages;\n    final int lastPage = totalPages;\n\n    //If currentPage is lastPage, then do nothing;\n    //If currentPage is < lastPage, then set currentPage to currentPage + 1;\n\n    if (currentPage == lastPage) {\n      return;\n    }\n    decoration.action.onValueChanged!(currentPage + 1);\n  }\n}\n\nclass _PreviousNextButton extends StatelessWidget {\n  final bool isNext;\n  final VoidCallback? onTap;\n  final PaginationDecoration decoration;\n\n  const _PreviousNextButton(\n      {this.isNext = false, this.onTap, required this.decoration});\n\n  @override\n  Widget build(BuildContext context) {\n    if (isNext) {\n      return DefaultButton(\n        type: decoration.color.arrowButtonType!,\n        decorationBuilder: (context, type) {\n          return ButtonDecoration(\n            context,\n            type: type,\n            size: ButtonSize(context, type,\n                minimumSize: decoration.size.buttonMinSize),\n            child: ButtonChild(context, icon: decoration.color.nextButtonIcon!),\n            action: ButtonAction(context, onPressed: onTap),\n          );\n        },\n      );\n    }\n    return DefaultButton(\n      type: decoration.color.arrowButtonType!,\n      decorationBuilder: (context, type) {\n        return ButtonDecoration(\n          context,\n          type: type,\n          size: ButtonSize(context, type,\n              minimumSize: decoration.size.buttonMinSize),\n          child:\n              ButtonChild(context, icon: decoration.color.previousButtonIcon!),\n          action: ButtonAction(context, onPressed: onTap),\n        );\n      },\n    );\n  }\n}\n"
  },
  {
    "name": "radio",
    "version": "0.0.1",
    "dependencies": [
      "form",
      "disabled",
      "dp_item"
    ],
    "content": "//v0.0.1\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nimport 'fcnui_theme.dart';\nimport 'disabled.dart';\nimport 'dp_item.dart';\n\nclass RadioDecoration extends DecorationImpl {\n  RadioDecoration(\n    super.themeVm, {\n    RadioChild? child,\n    RadioColor? color,\n    required RadioValue value,\n    RadioAction? action,\n  }) {\n    super.value = value;\n    super.child = child ?? RadioChild(themeVm);\n    super.color = color ?? RadioColor(themeVm);\n    super.action = action ?? RadioAction(themeVm);\n  }\n\n  @override\n  RadioChild get child => super.child as RadioChild;\n\n  @override\n  RadioColor get color => super.color as RadioColor;\n\n  @override\n  RadioValue get value => super.value as RadioValue;\n\n  @override\n  RadioAction get action => super.action as RadioAction;\n}\n\nclass RadioValue extends ValueImpl {\n  RadioValue(\n    super.themeVm, {\n    required this.name,\n    required this.items,\n    this.validator,\n    this.initialValue,\n    this.disabledItems = const [],\n    this.autovalidateMode = AutovalidateMode.onUserInteraction,\n  });\n\n  final String name;\n  final List<DpItem> items;\n  final FormFieldValidator<String>? validator;\n  final String? initialValue;\n  final List<String> disabledItems;\n  final AutovalidateMode autovalidateMode;\n}\n\nclass RadioChild extends ChildImpl {\n  RadioChild(\n    super.themeVm, {\n    this.title,\n    this.controlAffinity = ControlAffinity.leading,\n    this.direction = OptionsOrientation.vertical,\n    this.separatorWidget,\n    TextStyle? titleStyle,\n    TextStyle? itemTitleStyle,\n    TextStyle? itemSubtitleStyle,\n  }) {\n    void setTextStyle() {\n      this.titleStyle = titleStyle ?? theme.textTheme.titleSmall;\n      this.itemTitleStyle = itemTitleStyle ?? theme.textTheme.bodyMedium;\n      this.itemSubtitleStyle = itemSubtitleStyle ??\n          theme.textTheme.bodySmall!\n              .copyWith(color: theme.colorScheme.onSurface.withOpacity(0.6));\n    }\n\n    setTextStyle();\n  }\n\n  final String? title;\n  TextStyle? titleStyle;\n  final ControlAffinity controlAffinity;\n  final OptionsOrientation direction;\n  final Widget? separatorWidget;\n\n  TextStyle? itemTitleStyle;\n  TextStyle? itemSubtitleStyle;\n}\n\nclass RadioColor extends ColorImpl {\n  RadioColor(\n    super.themeVm, {\n    Color? activeColor,\n    Color? inactiveColor,\n    Color? disabledColor,\n    Color? errorColor,\n  }) {\n    void setColor() {\n      this.activeColor = activeColor ?? primary;\n      this.inactiveColor = inactiveColor ?? onSurface.withOpacity(0.6);\n      this.errorColor = errorColor ?? Colors.red;\n    }\n\n    setColor();\n  }\n\n  Color? activeColor;\n  Color? inactiveColor;\n  Color? disabledColor;\n  Color? errorColor;\n}\n\nclass RadioAction extends ActionImpl<String> {\n  RadioAction(super.themeVm, {this.onChanged});\n\n  final ValueChanged<String?>? onChanged;\n}\n\ntypedef RadioDecorationBuilder = RadioDecoration Function(ThemeVm themeVm);\n\nclass DefaultRadio extends StatelessWidget {\n  final RadioDecorationBuilder decorationBuilder;\n\n  const DefaultRadio({super.key, required this.decorationBuilder});\n\n  RadioThemeData _getRadioTheme(RadioDecoration decoration) {\n    return RadioThemeData(\n      splashRadius: 8,\n      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,\n      fillColor: MaterialStateProperty.resolveWith((states) {\n        //if selected\n        if (states.contains(MaterialState.selected)) {\n          return decoration.color.activeColor;\n        }\n        if (states.contains(MaterialState.disabled)) {\n          return decoration.color.disabledColor;\n        }\n        return decoration.color.inactiveColor;\n      }),\n      mouseCursor: MaterialStateProperty.resolveWith((states) {\n        //if disabled return not-allowed\n        if (states.contains(MaterialState.disabled)) {\n          return SystemMouseCursors.forbidden;\n        }\n        return null;\n      }),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ThemeProvider(builder: (context, themeVm) {\n      final decoration = decorationBuilder(themeVm);\n      return DefaultDisabled(\n          decorationBuilder: (context) => DisabledDecoration(context,\n              state: DisabledState(context,\n                  isDisabled: decoration.action.onChanged == null),\n              child: DisabledChild(context,\n                  child: ThemeProvider(builder: (context, themeVm) {\n                final theme = themeVm.theme;\n                return Theme(\n                    data: theme.copyWith(\n                      inputDecorationTheme: InputDecorationTheme(\n                          border: InputBorder.none,\n                          focusedBorder: InputBorder.none,\n                          enabledBorder: InputBorder.none,\n                          errorBorder: InputBorder.none,\n                          disabledBorder: InputBorder.none,\n                          focusedErrorBorder: InputBorder.none,\n                          contentPadding: EdgeInsets.zero,\n                          errorStyle:\n                              TextStyle(color: decoration.color.errorColor),\n                          errorMaxLines: 2),\n                      radioTheme: _getRadioTheme(decoration),\n                    ),\n                    child: Column(\n                        mainAxisSize: MainAxisSize.min,\n                        crossAxisAlignment: CrossAxisAlignment.start,\n                        children: [\n                          if (decoration.child.title != null)\n                            Text(decoration.child.title!,\n                                style: decoration.child.titleStyle),\n                          FormBuilderRadioGroup<String>(\n                              name: decoration.value.name,\n                              onChanged: decoration.action.onChanged,\n                              enabled: decoration.action.onChanged != null,\n                              validator: decoration.value.validator,\n                              initialValue: decoration.value.initialValue,\n                              disabled: decoration.value.disabledItems,\n                              controlAffinity: decoration.child.controlAffinity,\n                              autovalidateMode:\n                                  decoration.value.autovalidateMode,\n                              separator: decoration.child.separatorWidget,\n                              orientation: decoration.child.direction,\n                              wrapDirection: decoration.child.direction ==\n                                      OptionsOrientation.vertical\n                                  ? Axis.vertical\n                                  : Axis.horizontal,\n                              wrapRunSpacing: 12.w,\n                              wrapSpacing: 12.w,\n                              options: decoration.value.items\n                                  .map((e) => FormBuilderFieldOption(\n                                      value: e.id,\n                                      child: DefaultDisabled(\n                                          decorationBuilder: (context) =>\n                                              DisabledDecoration(context,\n                                                  state: DisabledState(context,\n                                                      isDisabled: decoration\n                                                          .value.disabledItems\n                                                          .contains(e.id)),\n                                                  child: DisabledChild(context,\n                                                      child: Column(\n                                                          mainAxisSize:\n                                                              MainAxisSize.min,\n                                                          crossAxisAlignment:\n                                                              CrossAxisAlignment\n                                                                  .start,\n                                                          children: [\n                                                            Text(e.title,\n                                                                style: decoration\n                                                                    .child\n                                                                    .itemTitleStyle),\n                                                            if (e.subtitle !=\n                                                                null)\n                                                              Text(e.subtitle!,\n                                                                  style: decoration\n                                                                      .child\n                                                                      .itemSubtitleStyle)\n                                                          ]))))))\n                                  .toList())\n                        ]).spaced(8));\n              }))));\n    });\n  }\n}\n"
  },
  {
    "name": "dp_item",
    "version": "0.0.1",
    "content": "//v0.0.1\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nclass DpItem extends Equatable {\n  final String id;\n  final String title;\n  final String? subtitle;\n  final IconData? icon;\n\n  const DpItem(\n      {required this.id, required this.title, this.subtitle, this.icon});\n\n  @override\n  List<Object?> get props => [id, title, subtitle, icon];\n\n  //copyWith\n  DpItem copyWith({\n    String? id,\n    String? title,\n    String? subtitle,\n    IconData? icon,\n  }) {\n    return DpItem(\n      id: id ?? this.id,\n      title: title ?? this.title,\n      subtitle: subtitle ?? this.subtitle,\n      icon: icon ?? this.icon,\n    );\n  }\n}\n"
  },
  {
    "name": "select",
    "version": "0.0.1",
    "dependencies": [
      "disabled",
      "form",
      "input"
    ],
    "content": "import 'dart:convert';\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nimport 'disabled.dart';\nimport 'form.dart';\nimport 'input.dart';\nimport 'fcnui_theme.dart';\n\nclass DefaultSelect<T> extends StatefulWidget {\n  final SelectOptions<T> options;\n  final SelectForm<T> form;\n  final SelectDecoration<T> decoration;\n  final SelectNetwork<T>? networkConfig;\n\n  const DefaultSelect({\n    super.key,\n    this.options = const SelectOptions(),\n    required this.form,\n    this.networkConfig,\n    this.decoration = const SelectDecoration(),\n  });\n\n  /// Constructor for DefaultSelect that fetches the options from a network call.\n  /// [networkConfig] is the configuration for the network call.\n  /// [responseParser] is the parser that is used to parse the response from the network call.\n  /// [responseErrorBuilder] is the builder that is used to build the error widget when the network call fails.\n\n  const DefaultSelect.network({\n    super.key,\n    required this.form,\n    this.options = const SelectOptions(),\n    required this.networkConfig,\n    this.decoration = const SelectDecoration(),\n  });\n\n  @override\n  State<DefaultSelect<T>> createState() => _DefaultSelectState<T>();\n}\n\nclass _DefaultSelectState<T> extends State<DefaultSelect<T>> {\n  SelectDecoration<T> get decoration => widget.decoration;\n\n  SelectOptions<T> get dpOptions => widget.options;\n\n  List<ValueItem<T>> get options => widget.options.options;\n\n  SelectForm<T> get form => widget.form;\n\n  SelectNetwork<T>? get networkConfig => widget.networkConfig;\n\n  /// Options list that is used to display the options.\n  final List<ValueItem<T>> _options = [];\n\n  /// Selected options list that is used to display the selected options.\n  final List<ValueItem<T>> _selectedOptions = [];\n\n  /// Disabled options list that is used to display the disabled options.\n  final List<ValueItem<T>> _disabledOptions = [];\n\n  /// The controller for the dropdown.\n  OverlayState? _overlayState;\n  OverlayEntry? _overlayEntry;\n  bool _selectionMode = false;\n\n  late final FocusNode _focusNode;\n  final LayerLink _layerLink = LayerLink();\n\n  /// Response from the network call.\n  dynamic _reponseBody;\n\n  /// value notifier that is used for controller.\n  late SelectController<T> _controller;\n\n  /// search field focus node\n  FocusNode? _searchFocusNode;\n\n  bool get isMultiSelection => decoration.selectionType == SelectionType.multi;\n\n  double get dropdownHeight {\n    double height = 0;\n    for (final option in _options) {\n      height += 43;\n      if (option.subtitle != null) {\n        height += 11;\n      }\n    }\n    return height;\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addPostFrameCallback((_) async {\n      await _initialize();\n    });\n\n    _focusNode = FocusNode();\n    _controller = decoration.controller ?? SelectController<T>();\n  }\n\n  /// Initializes the options, selected options and disabled options.\n  /// If the options are fetched from the network, then the network call is made.\n  /// If the options are passed as a parameter, then the options are initialized.\n  Future<void> _initialize() async {\n    if (!mounted) return;\n    if (networkConfig?.networkConfig != null) {\n      await _fetchNetwork();\n    } else {\n      _options.addAll(_controller.options.isNotEmpty == true\n          ? _controller.options\n          : options);\n    }\n    _addOptions();\n    if (mounted) {\n      _initializeOverlay();\n    } else {\n      WidgetsBinding.instance.addPostFrameCallback((timeStamp) {\n        _initializeOverlay();\n      });\n    }\n  }\n\n  @override\n  void didUpdateWidget(covariant DefaultSelect<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    // if (_options != options) {\n    //   _options.clear();\n    //   _options.addAll(options);\n    // }\n  }\n\n  void _initializeOverlay() {\n    _overlayState ??= Overlay.of(context);\n\n    _focusNode.addListener(_handleFocusChange);\n\n    if (decoration.searchEnabled) {\n      _searchFocusNode = FocusNode();\n      _searchFocusNode!.addListener(_handleFocusChange);\n    }\n  }\n\n  /// Adds the selected options and disabled options to the options list.\n  void _addOptions() {\n    setState(() {\n      _selectedOptions.addAll(_controller.selectedOptions.isNotEmpty == true\n          ? _controller.selectedOptions\n          : dpOptions.selectedOptions);\n      _disabledOptions.addAll(_controller.disabledOptions.isNotEmpty == true\n          ? _controller.disabledOptions\n          : dpOptions.disabledOptions);\n    });\n\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      if (_controller._isDisposed == false) {\n        _controller.setOptions(_options);\n        _controller.setSelectedOptions(_selectedOptions);\n        _controller.setDisabledOptions(_disabledOptions);\n\n        _controller.addListener(_handleControllerChange);\n      }\n    });\n  }\n\n  /// Handles the focus change to show/hide the dropdown.\n  void _handleFocusChange() {\n    if (_focusNode.hasFocus && mounted) {\n      _overlayEntry = _buildOverlayEntry();\n      Overlay.of(context).insert(_overlayEntry!);\n      _updateSelection();\n      return;\n    }\n\n    if ((_searchFocusNode == null || _searchFocusNode?.hasFocus == false) &&\n        _overlayEntry != null) {\n      _overlayEntry?.remove();\n      // ignore: invalid_use_of_protected_member, invalid_use_of_visible_for_testing_member\n      _controller.notifyListeners();\n    }\n\n    if (mounted) _updateSelection();\n\n    _controller.value._isDropdownOpen =\n        _focusNode.hasFocus || _searchFocusNode?.hasFocus == true;\n    // ignore: invalid_use_of_protected_member, invalid_use_of_visible_for_testing_member\n    _controller.notifyListeners();\n  }\n\n  void _updateSelection() {\n    setState(() {\n      _selectionMode =\n          _focusNode.hasFocus || _searchFocusNode?.hasFocus == true;\n    });\n  }\n\n  /// Calculate offset size for dropdown.\n  List _calculateOffsetSize() {\n    RenderBox? renderBox = context.findRenderObject() as RenderBox?;\n\n    var size = renderBox?.size ?? Size.zero;\n    var offset = renderBox?.localToGlobal(Offset.zero) ?? Offset.zero;\n\n    final availableHeight = MediaQuery.of(context).size.height - offset.dy;\n    if (decoration.customWidget != null) {\n      return [\n        decoration.dropdownMenuSize ?? const Size.fromWidth(300),\n        availableHeight < dropdownHeight,\n      ];\n    }\n\n    return [\n      decoration.dropdownMenuSize ?? size,\n      availableHeight < dropdownHeight,\n    ];\n  }\n\n  /// Dispose the focus node and overlay entry.\n  @override\n  void dispose() {\n    if (_overlayEntry?.mounted == true) {\n      if (_overlayState != null && _overlayEntry != null) {\n        _overlayEntry?.remove();\n      }\n      _overlayEntry = null;\n      _overlayState?.dispose();\n    }\n    _focusNode.removeListener(_handleFocusChange);\n    _searchFocusNode?.removeListener(_handleFocusChange);\n    _focusNode.dispose();\n    _searchFocusNode?.dispose();\n    _controller.removeListener(_handleControllerChange);\n\n    if (decoration.controller == null ||\n        decoration.controller?.isDisposed == true) {\n      _controller.dispose();\n    }\n\n    super.dispose();\n  }\n\n  /// Util method to map with index.\n  Iterable<E> mapIndexed<E, F>(\n      Iterable<F> items, E Function(int index, F item) f) sync* {\n    var index = 0;\n\n    for (final item in items) {\n      yield f(index, item);\n      index = index + 1;\n    }\n  }\n\n  /// Handle the focus change on tap outside of the dropdown.\n  void _onOutSideTap() {\n    if (_searchFocusNode != null) {\n      _searchFocusNode!.unfocus();\n    }\n    _focusNode.unfocus();\n  }\n\n  /// Method to toggle the focus of the dropdown.\n  void _toggleFocus() {\n    if (_focusNode.hasFocus) {\n      _focusNode.unfocus();\n    } else {\n      _focusNode.requestFocus();\n    }\n  }\n\n  /// Clear the selected options.\n  /// [SelectController] is used to clear the selected options.\n  void clear() {\n    if (!_controller._isDisposed) {\n      _controller.clearAllSelection();\n    } else {\n      setState(() {\n        _selectedOptions.clear();\n      });\n      dpOptions.onOptionSelected?.call(_selectedOptions);\n    }\n    if (_focusNode.hasFocus) _focusNode.unfocus();\n  }\n\n  /// handle the controller change.\n  void _handleControllerChange() {\n    // if the controller is null, return.\n    if (_controller.isDisposed == true) return;\n\n    // if current disabled options are not equal to the controller's disabled options, update the state.\n    if (_disabledOptions != _controller.value._disabledOptions) {\n      setState(() {\n        _disabledOptions.clear();\n        _disabledOptions.addAll(_controller.value._disabledOptions);\n      });\n    }\n\n    // if current options are not equal to the controller's options, update the state.\n    if (_options != _controller.value._options) {\n      setState(() {\n        _options.clear();\n        _options.addAll(_controller.value._options);\n      });\n    }\n\n    // if current selected options are not equal to the controller's selected options, update the state.\n    if (_selectedOptions != _controller.value._selectedOptions) {\n      setState(() {\n        _selectedOptions.clear();\n        _selectedOptions.addAll(_controller.value._selectedOptions);\n      });\n      dpOptions.onOptionSelected?.call(_selectedOptions);\n    }\n\n    if (_selectionMode != _controller.value._isDropdownOpen) {\n      if (_controller.value._isDropdownOpen) {\n        _focusNode.requestFocus();\n      } else {\n        _focusNode.unfocus();\n      }\n    }\n  }\n\n  bool isLoading = false;\n\n  /// Make a request to the provided url.\n  /// The response then is parsed to a list of ValueItem objects.\n  Future<void> _fetchNetwork() async {\n    setState(() {\n      isLoading = true;\n    });\n    final result = await _performNetworkRequest();\n    get(Uri.parse(networkConfig!.networkConfig!.url));\n    if (result.statusCode == 200) {\n      final data = json.decode(result.body);\n      final List<ValueItem<T>> parsedOptions =\n          await networkConfig!.responseParser!(data);\n      _reponseBody = null;\n      _options.addAll(parsedOptions);\n    } else {\n      _reponseBody = result.body;\n    }\n    setState(() {\n      isLoading = false;\n    });\n  }\n\n  /// Perform the network request according to the provided configuration.\n  Future<Response> _performNetworkRequest() async {\n    switch (networkConfig!.networkConfig!.method) {\n      case RequestMethod.get:\n        return await get(\n          Uri.parse(networkConfig!.networkConfig!.url),\n          headers: networkConfig!.networkConfig!.headers,\n        );\n      case RequestMethod.post:\n        return await post(\n          Uri.parse(networkConfig!.networkConfig!.url),\n          body: networkConfig!.networkConfig!.body,\n          headers: networkConfig!.networkConfig!.headers,\n        );\n      case RequestMethod.put:\n        return await put(\n          Uri.parse(networkConfig!.networkConfig!.url),\n          body: networkConfig!.networkConfig!.body,\n          headers: networkConfig!.networkConfig!.headers,\n        );\n      case RequestMethod.patch:\n        return await patch(\n          Uri.parse(networkConfig!.networkConfig!.url),\n          body: networkConfig!.networkConfig!.body,\n          headers: networkConfig!.networkConfig!.headers,\n        );\n      case RequestMethod.delete:\n        return await delete(\n          Uri.parse(networkConfig!.networkConfig!.url),\n          headers: networkConfig!.networkConfig!.headers,\n        );\n      default:\n        return await get(\n          Uri.parse(networkConfig!.networkConfig!.url),\n          headers: networkConfig!.networkConfig!.headers,\n        );\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ThemeProvider(builder: (context, themeVm) {\n      return Theme(\n          data: themeVm.theme,\n          child: DefaultDisabled(\n              decorationBuilder: (themeVm) => DisabledDecoration(themeVm,\n                  state: DisabledState(themeVm,\n                      isDisabled: isLoading || decoration.disabled),\n                  child: DisabledChild(themeVm,\n                      child: Semantics(\n                          button: true,\n                          enabled: true,\n                          child: CompositedTransformTarget(\n                              link: _layerLink,\n                              child: Focus(\n                                  canRequestFocus: true,\n                                  skipTraversal: true,\n                                  focusNode: _focusNode,\n                                  child: FormBuilderField<List<ValueItem<T>>>(\n                                      name: form.name,\n                                      validator: (value) {\n                                        if (value == null) return null;\n                                        return form.validator?.call(value);\n                                      },\n                                      initialValue: _selectedOptions,\n                                      onChanged: (value) {\n                                        if (value != null) {\n                                          dpOptions.onOptionSelected\n                                              ?.call(value);\n                                        }\n                                      },\n                                      enabled: !decoration.disabled,\n                                      builder: (field) {\n                                        final errorText = field.errorText;\n                                        final hasError = errorText != null;\n                                        return Column(\n                                            crossAxisAlignment:\n                                                CrossAxisAlignment.start,\n                                            mainAxisSize: MainAxisSize.min,\n                                            children: [\n                                              InkWell(\n                                                splashFactory:\n                                                    NoSplash.splashFactory,\n                                                overlayColor:\n                                                    MaterialStatePropertyAll(\n                                                        FcnuiDefaultColor(\n                                                                context)\n                                                            .borderColor),\n                                                radius: FcnuiDefaultSizes\n                                                    .borderRadius,\n                                                borderRadius:\n                                                    BorderRadius.circular(\n                                                        FcnuiDefaultSizes\n                                                            .borderRadius),\n                                                onTap: _toggleFocus,\n                                                child: decoration\n                                                        .customWidget ??\n                                                    AnimatedContainer(\n                                                      duration: const Duration(\n                                                          milliseconds: 200),\n                                                      height:\n                                                          decoration.wrapType ==\n                                                                  WrapType.wrap\n                                                              ? null\n                                                              : decoration\n                                                                      .height\n                                                                      ?.h ??\n                                                                  50.h,\n                                                      constraints:\n                                                          BoxConstraints(\n                                                        minWidth: MediaQuery.of(\n                                                                context)\n                                                            .size\n                                                            .width,\n                                                        minHeight: decoration\n                                                                .height?.h ??\n                                                            50.h,\n                                                      ),\n                                                      padding:\n                                                          _getContainerPadding(),\n                                                      decoration:\n                                                          _getContainerDecoration(\n                                                              themeVm.theme,\n                                                              hasError),\n                                                      child: Row(\n                                                        crossAxisAlignment:\n                                                            CrossAxisAlignment\n                                                                .center,\n                                                        children: [\n                                                          Expanded(\n                                                              child:\n                                                                  _getContainerContent()),\n                                                          if (_anyItemSelected) ...[\n                                                            const SizedBox(\n                                                                    width: FcnuiDefaultSizes\n                                                                        .itemSpacing)\n                                                                .w,\n                                                            if (isMultiSelection &&\n                                                                decoration\n                                                                    .showClearIcon)\n                                                              InkWell(\n                                                                  onTap: () =>\n                                                                      clear(),\n                                                                  child:\n                                                                      const Icon(\n                                                                    Icons.close,\n                                                                    size: FcnuiDefaultSizes\n                                                                        .iconSize,\n                                                                  )),\n                                                            const SizedBox(\n                                                                    width: FcnuiDefaultSizes\n                                                                        .itemSpacing)\n                                                                .w\n                                                          ],\n                                                          _buildSuffixIcon(),\n                                                        ],\n                                                      ),\n                                                    ),\n                                              ),\n                                              if (hasError)\n                                                Padding(\n                                                    padding:\n                                                        const EdgeInsets.only(\n                                                            top: 4.0),\n                                                    child: Text(errorText,\n                                                        style: TextStyle(\n                                                            color:\n                                                                FcnuiDefaultColor(\n                                                                        context)\n                                                                    .errorColor,\n                                                            fontSize: 12.sp)))\n                                            ]);\n                                      }))))))));\n    });\n  }\n\n  Widget _buildSuffixIcon() {\n    return AnimatedRotation(\n      turns: _selectionMode ? 0.5 : 0,\n      duration: const Duration(milliseconds: 200),\n      child: isLoading\n          ? const Center(child: CircularProgressIndicator())\n          : Icon(\n              Icons.keyboard_arrow_down_outlined,\n              size: FcnuiDefaultSizes.iconSize,\n              color: FcnuiDefaultColor(context).greyColor,\n            ),\n    );\n  }\n\n  /// Container Content for the dropdown.\n  Widget _getContainerContent() {\n    Widget column(String? value, Widget? child, {bool isGrey = false}) {\n      return Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        mainAxisSize: MainAxisSize.min,\n        children: [\n          if (decoration.labelText != null)\n            Text(\n              decoration.labelText!,\n              style: Theme.of(context).textTheme.bodySmall,\n            ),\n          if (value != null)\n            Text(\n              value,\n              maxLines: 1,\n              overflow: TextOverflow.ellipsis,\n              style: Theme.of(context).textTheme.bodyMedium!.copyWith(\n                  color: isGrey ? FcnuiDefaultColor(context).greyColor : null),\n            ),\n          if (child != null) child,\n        ],\n      );\n    }\n\n    if (_selectedOptions.isEmpty ||\n        decoration.showSelectedValuesContent == false) {\n      return column(decoration.hintText, null, isGrey: true);\n    }\n\n    if (decoration.selectionType == SelectionType.single) {\n      return column(_selectedOptions.first.label, null);\n    }\n\n    return column(null, _buildSelectedItems());\n  }\n\n  /// return true if any item is selected.\n  bool get _anyItemSelected => _selectedOptions.isNotEmpty;\n\n  /// Container decoration for the dropdown.\n  Decoration _getContainerDecoration(ThemeData theme, bool hasError) {\n    return BoxDecoration(\n      color: decoration.isColorful\n          ? theme.colorScheme.primary.withOpacity(.1)\n          : FcnuiDefaultColor(context).borderColor,\n      borderRadius: BorderRadius.circular(FcnuiDefaultSizes.borderRadius).r,\n      border: Border.all(\n              strokeAlign: BorderSide.strokeAlignOutside,\n              color: hasError\n                  ? FcnuiDefaultColor(context).errorColor\n                  : (_selectionMode ? theme.primaryColor : Colors.transparent),\n              width: _selectionMode\n                  ? FcnuiDefaultSizes.selectedBorderWidth\n                  : FcnuiDefaultSizes.borderWidth)\n          .w,\n    );\n  }\n\n  /// Build the selected items for the dropdown.\n  Widget _buildSelectedItems() {\n    if (decoration.wrapType == WrapType.ellipsis) {\n      final List<String> texts = [];\n      for (final item in _selectedOptions) {\n        texts.add(item.label);\n      }\n      return Text(\n        texts.join(\", \"),\n        maxLines: 1,\n        overflow: TextOverflow.ellipsis,\n        style: Theme.of(context).textTheme.bodyMedium,\n      );\n    }\n    return Wrap(\n        spacing: FcnuiDefaultSizes.itemSpacing,\n        runSpacing: FcnuiDefaultSizes.itemSpacing,\n        children: mapIndexed(_selectedOptions, (index, item) {\n          return _buildSelectedItem(\n              _selectedOptions[index],\n              !_disabledOptions.contains(_selectedOptions[index]),\n              index == _selectedOptions.length - 1);\n        }).toList());\n  }\n\n  /// Build the selected item chip.\n  Widget _buildSelectedItem(ValueItem<T> item, bool isEnabled, bool isLast) {\n    return Text(\n      \"${item.label}${isLast ? \"\" : \",\"}\",\n      style: const TextStyle(fontWeight: FontWeight.normal),\n      overflow: TextOverflow.ellipsis,\n      maxLines: 1,\n    );\n  }\n\n  /// Get the selectedItem icon for the dropdown\n  Widget? _getSelectedIcon(bool isSelected, ThemeData theme) {\n    return AnimatedOpacity(\n      opacity: isSelected ? 1 : 0,\n      duration: const Duration(milliseconds: 200),\n      child: Icon(\n        Icons.check,\n        color: decoration.isColorful\n            ? theme.primaryColor\n            : theme.colorScheme.onSurface,\n        size: FcnuiDefaultSizes.iconSize,\n      ),\n    );\n  }\n\n  Widget buildTransparentBox() {\n    return Positioned.fill(\n      child: GestureDetector(\n        behavior: HitTestBehavior.translucent,\n        onTap: _onOutSideTap,\n        child: const ColoredBox(\n          color: Colors.transparent,\n        ),\n      ),\n    );\n  }\n\n  /// Create the overlay entry for the dropdown.\n  OverlayEntry _buildOverlayEntry() {\n    // Calculate the offset and the size of the dropdown button\n    final values = _calculateOffsetSize();\n    // Get the size from the first item in the values list\n    final size = values[0] as Size;\n    // Get the showOnTop value from the second item in the values list\n    final showOnTop = values[1] as bool;\n\n    return OverlayEntry(builder: (context) {\n      List<ValueItem<T>> options = _options;\n      List<ValueItem<T>> selectedOptions = [..._selectedOptions];\n      final theme = Theme.of(context);\n\n      return StatefulBuilder(builder: ((context, dropdownState) {\n        return Stack(\n          children: [\n            buildTransparentBox(),\n            CompositedTransformFollower(\n              link: _layerLink,\n              showWhenUnlinked: true,\n              targetAnchor:\n                  showOnTop ? Alignment.topLeft : Alignment.bottomLeft,\n              followerAnchor:\n                  showOnTop ? Alignment.bottomLeft : Alignment.topLeft,\n              offset: Offset(0, showOnTop ? -5 : 5).w,\n              child: Material(\n                  elevation: 1,\n                  color: theme.colorScheme.surface,\n                  shape: RoundedRectangleBorder(\n                    borderRadius: BorderRadius.all(\n                      Radius.circular(FcnuiDefaultSizes.borderRadius.r),\n                    ),\n                    side: BorderSide(\n                        strokeAlign: BorderSide.strokeAlignInside,\n                        color: FcnuiDefaultColor(context).borderColor,\n                        width: FcnuiDefaultSizes.borderWidth),\n                  ),\n                  shadowColor: Colors.black12,\n                  child: Container(\n                    decoration: BoxDecoration(\n                      color: theme.dividerColor.withOpacity(.2),\n                      borderRadius: BorderRadius.circular(\n                          FcnuiDefaultSizes.borderRadius.r),\n                    ),\n                    constraints: decoration.searchEnabled\n                        ? BoxConstraints.loose(Size(size.width,\n                            (decoration.dropdownMenuMaxHeight ?? 200) + 50))\n                        : BoxConstraints.loose(Size(size.width,\n                            (decoration.dropdownMenuMaxHeight ?? 200))),\n                    child: _reponseBody != null && widget.networkConfig != null\n                        ? Center(\n                            child: networkConfig!.responseErrorBuilder!(\n                                context, _reponseBody),\n                          )\n                        : Column(\n                            mainAxisSize: MainAxisSize.min,\n                            children: [\n                              if (decoration.searchEnabled) ...[\n                                ColoredBox(\n                                  color: theme.dividerColor.withOpacity(.1),\n                                  child: Padding(\n                                    padding: const EdgeInsets.all(4.0).w,\n                                    child: DefaultInput(\n                                      decorationBuilder: (context) =>\n                                          InputDecor(\n                                        context,\n                                        child: InputChild(context,\n                                            name: \"search\",\n                                            hintText: decoration.hintText ??\n                                                \"Search\"),\n                                        state: InputState(context,\n                                            focusNode: _searchFocusNode),\n                                        action: InputAction(context,\n                                            onChanged: (value) {\n                                          if (value == null) return;\n                                          dropdownState(() {\n                                            options = _options.where((element) {\n                                              final label =\n                                                  element.label.toLowerCase();\n                                              final search =\n                                                  value.toLowerCase();\n                                              final subtitle = element.subtitle\n                                                      ?.toLowerCase() ??\n                                                  \"\";\n                                              return label.contains(search) ||\n                                                  subtitle.contains(search);\n                                            }).toList();\n                                          });\n                                        }),\n                                      ),\n                                    ),\n                                  ),\n                                ),\n                                Divider(height: 1.h),\n                              ],\n                              if (_options.isEmpty || options.isEmpty)\n                                Expanded(\n                                  child: Center(\n                                    child: Text(\n                                      \"Not found\",\n                                      style: theme.textTheme.bodyMedium,\n                                    ),\n                                  ),\n                                )\n                              else\n                                Expanded(\n                                  child: ListView.separated(\n                                    physics: const ClampingScrollPhysics(),\n                                    separatorBuilder: (_, __) => SizedBox(\n                                            height: isMultiSelection ? 2 : 0)\n                                        .w,\n                                    padding: const EdgeInsets.all(4).w,\n                                    itemCount: options.length,\n                                    itemBuilder: (context, index) {\n                                      final option = options[index];\n                                      final isSelected =\n                                          selectedOptions.contains(option);\n\n                                      onTap() {\n                                        if (decoration.selectionType ==\n                                            SelectionType.multi) {\n                                          if (isSelected) {\n                                            dropdownState(() {\n                                              selectedOptions.remove(option);\n                                            });\n                                            setState(() {\n                                              _selectedOptions.remove(option);\n                                            });\n                                            dpOptions.onOptionRemoved\n                                                ?.call(index, option);\n                                          } else {\n                                            final bool hasReachMax =\n                                                dpOptions.maxItems == null\n                                                    ? false\n                                                    : (_selectedOptions.length +\n                                                            1) >\n                                                        dpOptions.maxItems!;\n                                            if (hasReachMax) return;\n\n                                            dropdownState(() {\n                                              selectedOptions.add(option);\n                                            });\n                                            setState(() {\n                                              _selectedOptions.add(option);\n                                            });\n                                          }\n                                        } else {\n                                          if (isSelected) {\n                                            dropdownState(() {\n                                              selectedOptions.clear();\n                                              selectedOptions.add(option);\n                                            });\n                                            setState(() {\n                                              _selectedOptions.clear();\n                                            });\n                                          } else {\n                                            dropdownState(() {\n                                              selectedOptions.clear();\n                                              selectedOptions.add(option);\n                                            });\n                                            setState(() {\n                                              _selectedOptions.clear();\n                                              _selectedOptions.add(option);\n                                            });\n                                          }\n                                          _focusNode.unfocus();\n                                        }\n\n                                        _controller.value._selectedOptions\n                                            .clear();\n                                        _controller.value._selectedOptions\n                                            .addAll(_selectedOptions);\n\n                                        dpOptions.onOptionSelected\n                                            ?.call(_selectedOptions);\n                                      }\n\n                                      if (decoration.optionBuilder != null) {\n                                        return InkWell(\n                                          onTap: onTap,\n                                          splashFactory: NoSplash.splashFactory,\n                                          child: decoration.optionBuilder!(\n                                              context, option, isSelected),\n                                        );\n                                      }\n\n                                      final primaryColor =\n                                          Theme.of(context).primaryColor;\n\n                                      return _buildOption(\n                                        option: option,\n                                        primaryColor: primaryColor,\n                                        isSelected: isSelected,\n                                        dropdownState: dropdownState,\n                                        onTap: onTap,\n                                        selectedOptions: selectedOptions,\n                                        theme: Theme.of(context),\n                                      );\n                                    },\n                                  ),\n                                ),\n                            ],\n                          ),\n                  )),\n            ),\n          ],\n        );\n      }));\n    });\n  }\n\n  Widget _buildOption(\n      {required ValueItem<T> option,\n      required Color primaryColor,\n      required bool isSelected,\n      required StateSetter dropdownState,\n      required void Function() onTap,\n      required List<ValueItem<T>> selectedOptions,\n      required ThemeData theme}) {\n    bool enabled = true;\n\n    //if disabled contains the option, then it is disabled.\n    if (_disabledOptions.contains(option)) {\n      enabled = false;\n    }\n\n    bool hasReachedMax = dpOptions.maxItems == null\n        ? false\n        : (_selectedOptions.length + 1) > dpOptions.maxItems!;\n    //if _selectedOptions.length is equal to maxItems, then it is disabled.\n    if (hasReachedMax) {\n      if (isSelected == false) {\n        enabled = false;\n      }\n    }\n\n    if (dpOptions.optionItemBuilder != null) {\n      return DefaultDisabled(\n          decorationBuilder: (themeVm) => DisabledDecoration(themeVm,\n              state: DisabledState(themeVm, isDisabled: !enabled),\n              child: DisabledChild(themeVm,\n                  child: InkWell(\n                      onTap: onTap,\n                      splashFactory: NoSplash.splashFactory,\n                      child: dpOptions.optionItemBuilder!(\n                          context, option, isSelected)))));\n    }\n\n    return ListTile(\n      key: ValueKey(option.value),\n      splashColor: Colors.transparent,\n      mouseCursor:\n          enabled ? SystemMouseCursors.click : SystemMouseCursors.forbidden,\n      title: Text(option.label),\n      subtitle: option.subtitle != null ? Text(option.subtitle!) : null,\n      horizontalTitleGap: 10.w,\n      titleTextStyle: theme.textTheme.bodyMedium,\n      subtitleTextStyle: theme.textTheme.bodySmall!\n          .copyWith(color: theme.colorScheme.onSurface.withOpacity(0.6)),\n      selectedColor:\n          decoration.isColorful ? primaryColor : theme.colorScheme.onSurface,\n      selected: isSelected,\n      autofocus: true,\n      dense: true,\n      contentPadding: const EdgeInsets.symmetric(horizontal: 8, vertical: 0).w,\n      shape: RoundedRectangleBorder(\n          borderRadius:\n              BorderRadius.circular(FcnuiDefaultSizes.borderRadius).r),\n      tileColor: theme.colorScheme.surface,\n      selectedTileColor: decoration.isColorful\n          ? theme.primaryColor.withOpacity(.1)\n          : FcnuiDefaultColor(context).borderColor,\n      enabled: enabled,\n      onTap: onTap,\n      trailing: _getSelectedIcon(isSelected, theme),\n      leading: option.icon,\n    );\n  }\n\n  // get the container padding.\n  EdgeInsetsGeometry _getContainerPadding() {\n    if (decoration.selectionType == SelectionType.single) {\n      return const EdgeInsets.symmetric(\n              horizontal: FcnuiDefaultSizes.paddingHorizontal)\n          .w;\n    } else {\n      return const EdgeInsets.symmetric(\n              horizontal: FcnuiDefaultSizes.paddingHorizontal)\n          .w;\n    }\n  }\n}\n\n/// [SelectionType]\n/// SelectionType enum for the selection type of the dropdown items.\n/// * [single]: single selection\n/// * [multi]: multi selection\nenum SelectionType {\n  single,\n  multi,\n}\n\n/// [WrapType]\n/// WrapType enum for the wrap type of the selected items.\n/// * [WrapType.scroll]: scroll the selected items horizontally\n/// * [WrapType.wrap]: wrap the selected items in both directions\nenum WrapType { ellipsis, wrap }\n\n/// [RequestMethod]\n/// RequestMethod enum for the request method of the dropdown items.\n/// * [RequestMethod.get]: get request\n/// * [RequestMethod.post]: post request\n/// * [RequestMethod.put]: put request\n/// * [RequestMethod.delete]: delete request\n/// * [RequestMethod.patch]: patch request\nenum RequestMethod { get, post, put, patch, delete }\n\n/// Configuration for the network.\n///\n/// [url] is the url of the network.\n/// [method] is the request method of the network.\n/// [headers] is the headers of the network.\n/// [body] is the body of the network.\n/// [queryParameters] is the query parameters of the network.\n\nclass NetworkConfig {\n  final String url;\n  final RequestMethod method;\n  final Map<String, String>? headers;\n  final Map<String, dynamic>? body;\n  final Map<String, dynamic>? queryParameters;\n\n  NetworkConfig({\n    required this.url,\n    this.method = RequestMethod.get,\n    this.headers = const {},\n    this.body,\n    this.queryParameters = const {},\n  });\n}\n\n/// [label] is the item that is displayed in the list. [value] is the value that is returned when the item is selected.\n/// If the [value] is not provided, the [label] is used as the value.\n/// An example of a [ValueItem] is:\n/// ```dart\n/// const ValueItem(label: 'Option 1', value: '1')\n/// ```\n\nclass ValueItem<T> extends Equatable {\n  /// The label of the value item\n  final String label;\n\n  final String? subtitle;\n\n  /// The value of the value item\n  final T? value;\n\n  final Widget? icon;\n\n  /// Default constructor for [ValueItem]\n  const ValueItem(\n      {required this.label, required this.value, this.subtitle, this.icon});\n\n  /// toString method for [ValueItem]\n  @override\n  String toString() {\n    return 'ValueItem(label: $label, value: $value, subtitle: $subtitle)';\n  }\n\n  /// toMap method for [ValueItem]\n  Map<String, dynamic> toMap() {\n    return {\n      'label': label,\n      'value': value,\n      'subtitle': subtitle,\n      'icon': icon,\n    };\n  }\n\n  /// fromMap method for [ValueItem]\n  factory ValueItem.fromMap(Map<String, dynamic> map) {\n    return ValueItem<T>(\n      label: map['label'] ?? '',\n      value: map['value'],\n      subtitle: map['subtitle'],\n      icon: map['icon'],\n    );\n  }\n\n  /// toJson method for [ValueItem]\n  String toJson() => json.encode(toMap());\n\n  /// fromJson method for [ValueItem]\n  factory ValueItem.fromJson(String source) =>\n      ValueItem<T>.fromMap(json.decode(source));\n\n  /// CopyWith method for [ValueItem]\n  ValueItem<T> copyWith({\n    String? label,\n    T? value,\n    String? subtitle,\n    Widget? icon,\n  }) {\n    return ValueItem<T>(\n      label: label ?? this.label,\n      value: value ?? this.value,\n      subtitle: subtitle ?? this.subtitle,\n      icon: icon ?? this.icon,\n    );\n  }\n\n  @override\n  List<Object?> get props => [label, value, subtitle, icon];\n}\n\ntypedef OnOptionSelected<T> = void Function(List<ValueItem<T>> selectedOptions);\n\nclass SelectDecoration<T> extends Equatable {\n  final String? hintText;\n\n  final String? labelText;\n\n  // selection type of the dropdown\n  final SelectionType selectionType;\n\n  // options configuration\n  final double? dropdownHeight;\n\n  /// Controller for the dropdown\n  /// [controller] is the controller for the dropdown. It can be used to programmatically open and close the dropdown.\n  final SelectController<T>? controller;\n\n  /// Enable search\n  /// [searchEnabled] is the flag to enable search in dropdown. It is used to show search bar in dropdown.\n  final bool searchEnabled;\n\n  /// Use this if [customWidget] is provided\n  ///\n  /// Else it will calculate the size of the dropdown based on\n  ///\n  /// the size of the widget\n  final Size? dropdownMenuSize;\n\n  final double? dropdownMenuMaxHeight;\n\n  final Widget? customWidget;\n\n  final bool disabled;\n\n  /// option builder\n  /// [optionBuilder] is the builder that is used to build the option item.\n  /// The builder takes three arguments, the context, the option and the selected status of the option.\n  /// The builder returns a widget.\n  ///\n\n  final Widget Function(BuildContext ctx, ValueItem<T> option, bool selected)?\n      optionBuilder;\n\n  final WrapType wrapType;\n\n  final bool showSelectedValuesContent;\n\n  final bool showClearIcon;\n\n  final bool isColorful;\n\n  final double? height;\n\n  const SelectDecoration({\n    this.hintText,\n    this.selectionType = SelectionType.single,\n    this.dropdownHeight,\n    this.height,\n    this.showClearIcon = false,\n    this.showSelectedValuesContent = true,\n    this.controller,\n    this.searchEnabled = false,\n    this.dropdownMenuSize,\n    this.dropdownMenuMaxHeight,\n    this.customWidget,\n    this.optionBuilder,\n    this.wrapType = WrapType.ellipsis,\n    this.disabled = false,\n    this.labelText,\n    this.isColorful = false,\n  });\n\n  @override\n  List<Object?> get props => [\n        hintText,\n        selectionType,\n        dropdownHeight,\n        controller,\n        searchEnabled,\n        dropdownMenuSize,\n        dropdownMenuMaxHeight,\n        customWidget,\n        wrapType,\n        disabled,\n        labelText,\n        showSelectedValuesContent,\n        showClearIcon,\n        isColorful,\n        height,\n      ];\n}\n\nclass SelectForm<T> extends IFormModel {\n  const SelectForm({\n    required super.name,\n    this.validator,\n  });\n\n  //validator\n  final String? Function(List<ValueItem<T>>)? validator;\n\n  @override\n  List<Object?> get props => [name, validator];\n}\n\nclass SelectOptions<T> extends Equatable {\n  final List<ValueItem<T>> options;\n  final List<ValueItem<T>> selectedOptions;\n  final List<ValueItem<T>> disabledOptions;\n\n  final OnOptionSelected<T>? onOptionSelected;\n\n  /// [onOptionRemoved] is the callback that is called when an option is removed.The callback takes two arguments, the index of the removed option and the removed option.\n  /// This will be called only when the delete icon is clicked on the option chip.\n  ///\n  /// This will not be called when the option is removed programmatically.\n  ///\n  /// ```index``` is the index of the removed option.\n  ///\n  /// ```option``` is the removed option.\n  final void Function(int index, ValueItem<T> option)? onOptionRemoved;\n\n  /// Maximum number of items that can be selected\n  final int? maxItems;\n\n  final Widget Function(BuildContext context, ValueItem<T>, bool isSelected)?\n      optionItemBuilder;\n\n  const SelectOptions({\n    this.options = const [],\n    this.selectedOptions = const [],\n    this.disabledOptions = const [],\n    this.onOptionSelected,\n    this.onOptionRemoved,\n    this.maxItems,\n    this.optionItemBuilder,\n  });\n\n  @override\n  List<Object?> get props => [\n        options,\n        selectedOptions,\n        disabledOptions,\n        maxItems,\n      ];\n}\n\nclass SelectNetwork<T> extends Equatable {\n  const SelectNetwork({\n    required this.networkConfig,\n    required this.responseParser,\n    this.responseErrorBuilder,\n  });\n\n  final NetworkConfig? networkConfig;\n  final Future<List<ValueItem<T>>> Function(dynamic)? responseParser;\n  final Widget Function(BuildContext, dynamic)? responseErrorBuilder;\n\n  @override\n  List<Object?> get props =>\n      [networkConfig, responseParser, responseErrorBuilder];\n}\n\n/// MultiSelect Controller class.\n/// This class is used to control the state of the MultiDefaultSelect widget.\n/// This is just base class. The implementation of this class is in the SelectController class.\n/// The implementation of this class is hidden from the user.\nclass _SelectController<T> {\n  final List<ValueItem<T>> _disabledOptions = [];\n  final List<ValueItem<T>> _options = [];\n  final List<ValueItem<T>> _selectedOptions = [];\n  bool _isDropdownOpen = false;\n}\n\n/// implementation of the SelectController class.\nclass SelectController<T> extends ValueNotifier<_SelectController<T>> {\n  SelectController() : super(_SelectController());\n\n  bool _isDisposed = false;\n\n  bool get isDisposed => _isDisposed;\n\n  /// set the dispose method.\n  @override\n  void dispose() {\n    super.dispose();\n    _isDisposed = true;\n  }\n\n  /// Clear the selected options.\n  /// [SelectController] is used to clear the selected options.\n  void clearAllSelection() {\n    value._selectedOptions.clear();\n    notifyListeners();\n  }\n\n  /// clear specific selected option\n  /// [SelectController] is used to clear specific selected option.\n  void clearSelection(ValueItem<T> option) {\n    if (!value._selectedOptions.contains(option)) return;\n\n    if (value._disabledOptions.contains(option)) {\n      throw Exception('Cannot clear selection of a disabled option');\n    }\n\n    if (!value._options.contains(option)) {\n      throw Exception(\n          'Cannot clear selection of an option that is not in the options list');\n    }\n\n    value._selectedOptions.remove(option);\n    notifyListeners();\n  }\n\n  /// select the options\n  /// [SelectController] is used to select the options.\n  void setSelectedOptions(List<ValueItem<T>> options) {\n    if (options.any((element) => value._disabledOptions.contains(element))) {\n      throw Exception('Cannot select disabled options');\n    }\n\n    if (options.any((element) => !value._options.contains(element))) {\n      throw Exception('Cannot select options that are not in the options list');\n    }\n\n    value._selectedOptions.clear();\n    value._selectedOptions.addAll(options);\n    notifyListeners();\n  }\n\n  /// add selected option\n  /// [SelectController] is used to add selected option.\n  void addSelectedOption(ValueItem<T> option) {\n    if (value._disabledOptions.contains(option)) {\n      throw Exception('Cannot select disabled option');\n    }\n\n    if (!value._options.contains(option)) {\n      throw Exception('Cannot select option that is not in the options list');\n    }\n\n    value._selectedOptions.add(option);\n    notifyListeners();\n  }\n\n  /// set disabled options\n  /// [SelectController] is used to set disabled options.\n  void setDisabledOptions(List<ValueItem<T>> disabledOptions) {\n    if (disabledOptions.any((element) => !value._options.contains(element))) {\n      throw Exception(\n          'Cannot disable options that are not in the options list');\n    }\n\n    value._disabledOptions.clear();\n    value._disabledOptions.addAll(disabledOptions);\n    notifyListeners();\n  }\n\n  /// setDisabledOption method\n  /// [SelectController] is used to set disabled option.\n  void setDisabledOption(ValueItem<T> disabledOption) {\n    if (!value._options.contains(disabledOption)) {\n      throw Exception('Cannot disable option that is not in the options list');\n    }\n\n    value._disabledOptions.add(disabledOption);\n    notifyListeners();\n  }\n\n  /// set options\n  /// [SelectController] is used to set options.\n  void setOptions(List<ValueItem<T>> options) {\n    value._options.clear();\n    value._options.addAll(options);\n    notifyListeners();\n  }\n\n  /// get disabled options\n  List<ValueItem<T>> get disabledOptions => value._disabledOptions;\n\n  /// get enabled options\n  List<ValueItem<T>> get enabledOptions => value._options\n      .where((element) => !value._disabledOptions.contains(element))\n      .toList();\n\n  /// get options\n  List<ValueItem<T>> get options => value._options;\n\n  /// get selected options\n  List<ValueItem<T>> get selectedOptions => value._selectedOptions;\n\n  /// get is dropdown open\n  bool get isDropdownOpen => value._isDropdownOpen;\n\n  /// open dropdown\n  /// [SelectController] is used to open dropdown.\n  void openDropdown() {\n    if (value._isDropdownOpen) return;\n    value._isDropdownOpen = true;\n    notifyListeners();\n  }\n\n  /// close dropdown\n  /// [SelectController] is used to close dropdown.\n  void closeDropdown() {\n    if (!value._isDropdownOpen) return;\n    value._isDropdownOpen = false;\n    notifyListeners();\n  }\n}\n"
  },
  {
    "name": "switch",
    "version": "0.0.1",
    "dependencies": [
      "form",
      "disabled"
    ],
    "content": "//v0.0.1\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nimport 'fcnui_theme.dart';\nimport 'disabled.dart';\n\nclass SwitchDecoration extends DecorationImpl {\n  SwitchDecoration(\n    super.themeVm, {\n    required SwitchValue value,\n    SwitchAction? action,\n    SwitchState? state,\n    SwitchChild? child,\n    SwitchColor? color,\n    SwitchSize? size,\n  }) {\n    this.value = value;\n    this.action = action ?? SwitchAction(themeVm);\n    this.state = state ?? SwitchState(themeVm);\n    this.child = child ?? SwitchChild(themeVm);\n    this.color = color ?? SwitchColor(themeVm);\n    this.size = size ?? SwitchSize(themeVm);\n  }\n\n  @override\n  SwitchValue get value => super.value as SwitchValue;\n\n  @override\n  SwitchAction get action => super.action as SwitchAction;\n\n  @override\n  SwitchState get state => super.state as SwitchState;\n\n  @override\n  SwitchChild get child => super.child as SwitchChild;\n\n  @override\n  SwitchColor get color => super.color as SwitchColor;\n\n  @override\n  SwitchSize get size => super.size as SwitchSize;\n}\n\nclass SwitchAction extends ActionImpl {\n  SwitchAction(super.themeVm, {this.onChanged});\n\n  final ValueChanged<bool?>? onChanged;\n}\n\nclass SwitchState extends StateImpl {\n  SwitchState(super.themeVm, {super.isDisabled = false});\n}\n\nclass SwitchValue extends ValueImpl {\n  SwitchValue(\n    super.themeVm, {\n    this.autovalidateMode = AutovalidateMode.onUserInteraction,\n    this.validator,\n    this.initialValue,\n    required this.name,\n  });\n\n  final String name;\n  final bool? initialValue;\n  final String? Function(bool?)? validator;\n  final AutovalidateMode? autovalidateMode;\n}\n\nclass SwitchChild extends ChildImpl {\n  SwitchChild(\n    super.themeVm, {\n    this.title,\n    this.subtitle,\n    this.thumbActiveIcon,\n    this.thumbInactiveIcon,\n    TextStyle? titleStyle,\n    TextStyle? subtitleStyle,\n    TextStyle? errorStyle,\n  }) {\n    void setTextStyle() {\n      this.titleStyle = titleStyle ?? theme.textTheme.titleSmall;\n      this.subtitleStyle = subtitleStyle ??\n          theme.textTheme.bodySmall!\n              .copyWith(color: theme.colorScheme.onSurface.withOpacity(0.6));\n      this.errorStyle =\n          errorStyle ?? theme.textTheme.bodySmall!.copyWith(color: Colors.red);\n    }\n\n    setTextStyle();\n  }\n\n  String? title;\n  String? subtitle;\n\n  IconData? thumbActiveIcon;\n  IconData? thumbInactiveIcon;\n\n  TextStyle? titleStyle;\n  TextStyle? subtitleStyle;\n  TextStyle? errorStyle;\n}\n\nclass SwitchColor extends ColorImpl {\n  SwitchColor(\n    super.themeVm, {\n    Color? thumbActiveColor,\n    Color? thumbInactiveColor,\n    Color? trackActiveColor,\n    Color? trackInactiveColor,\n    Color? focusColor,\n    Color? trackOutlineColor,\n    Color? errorColor,\n  }) {\n    void setColor() {\n      this.thumbActiveColor = thumbActiveColor ?? Colors.white;\n      this.thumbInactiveColor = thumbInactiveColor ?? Colors.white;\n      this.trackActiveColor =\n          trackActiveColor ?? theme.colorScheme.primary.withOpacity(0.5);\n      this.trackInactiveColor =\n          trackInactiveColor ?? theme.colorScheme.onSurface.withOpacity(0.5);\n      this.focusColor =\n          focusColor ?? theme.colorScheme.primary.withOpacity(0.12);\n      this.trackOutlineColor =\n          trackOutlineColor ?? theme.colorScheme.onSurface.withOpacity(0.05);\n      this.errorColor = errorColor ?? Colors.red;\n    }\n\n    setColor();\n  }\n\n  Color? thumbActiveColor;\n  Color? thumbInactiveColor;\n  Color? trackActiveColor;\n  Color? trackInactiveColor;\n  Color? focusColor;\n  Color? trackOutlineColor;\n  Color? errorColor;\n}\n\nclass SwitchSize extends SizeImpl {\n  SwitchSize(super.themeVm,\n      {double? width, double? height, double? splashRadius}) {\n    void setSize() {\n      this.width = (width ?? 45).w;\n      this.height = (height ?? 24).h;\n      this.splashRadius = (splashRadius ?? 17).r;\n    }\n\n    setSize();\n  }\n\n  double? width;\n  double? height;\n  double? splashRadius;\n}\n\ntypedef SwitchDecorationBuilder = SwitchDecoration Function(ThemeVm themeVm);\n\nclass DefaultSwitch extends StatelessWidget {\n  final SwitchDecorationBuilder decorationBuilder;\n\n  const DefaultSwitch({super.key, required this.decorationBuilder});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultDisabled(decorationBuilder: (themeVm) {\n      final decoration = decorationBuilder(themeVm);\n      return DisabledDecoration(themeVm,\n          state:\n              DisabledState(themeVm, isDisabled: decoration.state.isDisabled),\n          child: DisabledChild(themeVm,\n              child: FormBuilderField<bool>(\n                  name: decoration.value.name,\n                  validator: decoration.value.validator,\n                  enabled: !decoration.state.isDisabled,\n                  initialValue: decoration.value.initialValue,\n                  onChanged: decoration.action.onChanged,\n                  autovalidateMode: decoration.value.autovalidateMode,\n                  builder: (field) {\n                    return _Switch(field: field, decoration: decoration);\n                  })));\n    });\n  }\n}\n\nclass _Switch extends StatefulWidget {\n  final FormFieldState<bool> field;\n  final SwitchDecoration decoration;\n\n  const _Switch({required this.field, required this.decoration});\n\n  @override\n  State<_Switch> createState() => _SwitchState();\n}\n\nclass _SwitchState extends State<_Switch> {\n  FormFieldState<bool> get field => widget.field;\n\n  SwitchDecoration get decoration => widget.decoration;\n\n  ThemeData get theme => decoration.theme;\n\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      field.didChange(decoration.value.initialValue ?? false);\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final errorText = field.errorText;\n    final isError = errorText != null;\n\n    return Theme(\n        data: theme.copyWith(\n          switchTheme: theme.switchTheme.copyWith(\n              trackOutlineWidth: MaterialStateProperty.all(0),\n              splashRadius: decoration.size.splashRadius),\n        ),\n        child: Column(\n            mainAxisSize: MainAxisSize.min,\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n              Row(\n                mainAxisSize: MainAxisSize.min,\n                children: [\n                  SizedBox(\n                      width: decoration.size.width,\n                      height: decoration.size.height,\n                      child: FittedBox(\n                          fit: BoxFit.cover,\n                          child: Switch(\n                            value: field.value ?? false,\n                            onChanged: field.didChange,\n                            focusColor: decoration.color.focusColor,\n                            thumbIcon:\n                                MaterialStateProperty.resolveWith((states) {\n                              //Handle states here. Ex: disabled, error, etc.\n                              //check if active\n                              if (field.value == true) {\n                                return Icon(decoration.child.thumbActiveIcon);\n                              }\n                              //check if inactive\n                              return Icon(decoration.child.thumbInactiveIcon);\n                            }),\n                            thumbColor:\n                                MaterialStateProperty.resolveWith((states) {\n                              //Handle states here. Ex: disabled, error, etc.\n                              //check if active\n                              if (field.value == true) {\n                                return decoration.color.thumbActiveColor;\n                              }\n                              //check if inactive\n                              return decoration.color.thumbInactiveColor;\n                            }),\n                            trackColor:\n                                MaterialStateProperty.resolveWith((states) {\n                              //Handle states here. Ex: disabled, error, etc.\n                              // check if active\n                              if (field.value == true) {\n                                return decoration.color.trackActiveColor;\n                              }\n                              //check if inactive\n                              return decoration.color.trackInactiveColor;\n                            }),\n                            trackOutlineColor:\n                                MaterialStateProperty.resolveWith((states) {\n                              return decoration.color.trackOutlineColor;\n                            }),\n                          ))).w,\n                  if (decoration.child.title != null ||\n                      decoration.child.subtitle != null)\n                    GestureDetector(\n                      onTap: () => field.didChange(field.value == null\n                          ? decoration.value.initialValue\n                          : !field.value!),\n                      child: Column(\n                        mainAxisSize: MainAxisSize.min,\n                        crossAxisAlignment: CrossAxisAlignment.start,\n                        children: [\n                          if (decoration.child.title != null)\n                            Text(decoration.child.title!,\n                                style: decoration.child.titleStyle!.copyWith(\n                                    fontWeight: FontWeight.normal,\n                                    color: isError\n                                        ? decoration.color.errorColor\n                                        : null)),\n                          if (decoration.child.subtitle != null)\n                            Text(decoration.child.subtitle!,\n                                style: decoration.child.subtitleStyle)\n                        ],\n                      ),\n                    ),\n                ],\n              ).spaced(4),\n              if (isError) Text(errorText, style: decoration.child.errorStyle)\n            ]).spaced(4));\n  }\n}\n"
  },
  {
    "name": "table",
    "version": "0.0.1",
    "dependencies": [
      "input",
      "card",
      "pagination",
      "select"
    ],
    "content": "import 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nimport 'select.dart';\nimport 'pagination.dart';\nimport 'card.dart';\nimport 'input.dart';\n\nextension PlutoRowExtension on PlutoRow {\n  DefaultRow toDefaultRow() {\n    return DefaultRow(\n      rowKey: key,\n      cells: cells.entries\n          .map((e) => DefaultCell(\n                key: e.key,\n                value: e.value.value,\n              ))\n          .toList(),\n    );\n  }\n}\n\nextension PlutoColumnExtension on PlutoColumn {\n  DefaultColumn toDefaultColumn() {\n    return DefaultColumn(\n      name: title,\n      key: field,\n      type:\n          type == PlutoColumnType.text() ? ColumnType.text : ColumnType.number,\n      hasCheckbox: enableRowChecked,\n      hasSort: enableSorting,\n      footerWidget: footerRenderer != null\n          ? (rows) {\n              final addedAll = rows.fold<int>(0, (previousValue, element) {\n                return previousValue +\n                    (element.cells\n                        .firstWhere(\n                          (element) => element.key == field,\n                        )\n                        .value as int);\n              });\n              return Center(child: Text(\"Total: $addedAll\"));\n            }\n          : null,\n    );\n  }\n}\n\nextension PlutoCellExtension on PlutoCell {\n  DefaultCell toDefaultCell() {\n    return DefaultCell(\n      cellKey: key,\n      key: column.field,\n      value: value,\n    );\n  }\n}\n\nclass TableController extends Equatable {\n  final List<DefaultColumn> columns;\n  final List<DefaultRow> rows;\n  final void Function(List<DefaultRow>) onAddRows;\n  final void Function(List<DefaultRow>) onRemoveRows;\n  final List<DefaultRow> Function() getSelectedRows;\n\n  /// If [isAscending] parameter is null, the table will toggle the sort direction\n  final void Function(DefaultColumn column, {bool? isAscending}) onSortBy;\n  final void Function() onClearSort;\n  final void Function() onUnselectAll;\n  final void Function() onSelectAll;\n  final void Function() onToggleSelectAll;\n  final void Function(DefaultColumn column) onHideColumn;\n  final void Function(DefaultColumn column) onShowColumn;\n  final void Function(DefaultColumn column) onToggleColumnVisibility;\n\n  DefaultColumn getColumnOfCell(DefaultCell cell) {\n    try {\n      return columns.firstWhere((element) => element.key == cell.key);\n    } catch (e) {\n      throw Exception('Column not found');\n    }\n  }\n\n  const TableController({\n    required this.columns,\n    required this.rows,\n    required this.onAddRows,\n    required this.onRemoveRows,\n    required this.getSelectedRows,\n    required this.onSortBy,\n    required this.onClearSort,\n    required this.onHideColumn,\n    required this.onSelectAll,\n    required this.onToggleSelectAll,\n    required this.onUnselectAll,\n    required this.onShowColumn,\n    required this.onToggleColumnVisibility,\n  });\n\n  @override\n  List<Object> get props => [columns, rows];\n}\n\nenum ColumnType { text, number }\n\ntypedef FooterWidget = Widget Function(List<DefaultRow> rows);\ntypedef CellWidget = Widget Function(DefaultCell cell, int rowIndex);\ntypedef FormatterCallback = String Function(dynamic value);\n\n@immutable\nclass DefaultColumn extends Equatable {\n  final String name;\n\n  /// The key must be unique\n  final String key;\n  final ColumnType type;\n  final bool hasCheckbox;\n  final bool hasSort;\n  final double? width;\n\n  /// Does not apply if [cellWidget] is not null\n  final TextAlign? cellTextAlign;\n  final TextAlign? titleTextAlign;\n  final Widget? titleWidget;\n\n  //Callbacks\n  final FooterWidget? footerWidget;\n\n  /// Use this to change the cell widget\n  ///\n  /// If needs to format the cell value, use [formatter]\n  final CellWidget? cellWidget;\n\n  /// Use this to format the cell value\n  ///\n  /// If needs to change the widget completely, use [cellWidget]\n  ///\n  /// ex: (value) => value.toStringAsFixed(2)\n  final FormatterCallback? formatter;\n\n  DefaultColumn({\n    required this.name,\n    required this.type,\n    required this.key,\n    this.hasCheckbox = false,\n    this.hasSort = true,\n    this.footerWidget,\n    this.cellWidget,\n    this.formatter,\n    this.width,\n    this.cellTextAlign,\n    this.titleTextAlign,\n    this.titleWidget,\n  }) : assert(key.isNotEmpty, 'Key cannot be empty') {\n    PlutoColumnType getType() {\n      return switch (type) {\n        ColumnType.text => PlutoColumnType.text(),\n        ColumnType.number => PlutoColumnType.number(),\n      };\n    }\n\n    plutoColumn = PlutoColumn(\n      title: name,\n      field: key,\n      enableContextMenu: false,\n      enableAutoEditing: false,\n      enableEditingMode: false,\n      enableDropToResize: false,\n      enableRowDrag: false,\n      enableColumnDrag: false,\n      enableRowChecked: hasCheckbox,\n      enableSorting: hasSort,\n      type: getType(),\n      footerRenderer: footerWidget == null\n          ? null\n          : (colContext) {\n              final rows = colContext.stateManager.rows\n                  .map((e) => e.toDefaultRow())\n                  .toList();\n              return footerWidget!(rows);\n            },\n      renderer: cellWidget == null\n          ? null\n          : (cellContext) {\n              return cellWidget!(\n                cellContext.cell.toDefaultCell(),\n                cellContext.rowIdx,\n              );\n            },\n      formatter: formatter == null\n          ? null\n          : (value) {\n              return formatter!(value);\n            },\n      width: width ?? PlutoGridSettings.columnWidth,\n      cellPadding: cellWidget != null ? EdgeInsets.zero : null,\n      titleTextAlign: PlutoColumnTextAlign.values.firstWhere(\n          (element) => element.name == titleTextAlign?.name, orElse: () {\n        return PlutoColumnTextAlign.left;\n      }),\n      textAlign: PlutoColumnTextAlign.values.firstWhere(\n          (element) => element.name == cellTextAlign?.name, orElse: () {\n        return PlutoColumnTextAlign.left;\n      }),\n      titleSpan: titleWidget == null ? null : WidgetSpan(child: titleWidget!),\n    );\n  }\n\n  late final PlutoColumn plutoColumn;\n\n  @override\n  List<Object> get props => [name, type, hasCheckbox, key, hasSort];\n}\n\n@immutable\nclass DefaultRow extends Equatable {\n  final List<DefaultCell> cells;\n\n  late final PlutoRow plutoRow;\n\n  final Key? rowKey;\n\n  DefaultRow({required this.cells, this.rowKey})\n      //assert that the keys are unique\n      : assert(cells.map((e) => e.key).toSet().length == cells.length,\n            'Cell keys must be unique') {\n    plutoRow = PlutoRow(\n      key: rowKey,\n      cells: Map.fromEntries(cells.map((e) => MapEntry(e.key, e.plutoCell))),\n    );\n  }\n\n  @override\n  List<Object> get props => [cells];\n}\n\n@immutable\nclass DefaultCell extends Equatable {\n  /// The key is the column key and must match\n  final String key;\n  final dynamic value;\n\n  late final PlutoCell plutoCell;\n\n  final Key? cellKey;\n\n  DefaultCell({required this.value, required this.key, this.cellKey}) {\n    parseValue() {\n      if (value is! num) {\n        if (value is String) {\n          if (num.tryParse(value) != null) {\n            return num.parse(value);\n          }\n        }\n      }\n      return value;\n    }\n\n    plutoCell = PlutoCell(key: cellKey, value: parseValue());\n  }\n\n  @override\n  List<Object> get props => [value, key];\n}\n\ntypedef GetTableController = void Function(TableController tableController);\n\n@immutable\nclass TableVm extends Equatable {\n  final List<DefaultColumn> columns;\n  final List<DefaultRow> rows;\n  final GetTableController getTableController;\n  final TableLocaleText localeText;\n  final bool selectWithOneTap;\n\n  final TableDecoration decoration;\n\n  TableVm({\n    required this.columns,\n    this.rows = const [],\n    this.localeText = const TableLocaleText(),\n    required this.getTableController,\n    this.decoration = const TableDecoration(),\n    this.selectWithOneTap = true,\n  })  : assert(columns.isNotEmpty, 'Columns cannot be empty'),\n        assert(columns.map((e) => e.key).toSet().length == columns.length,\n            'Column keys must be unique');\n\n  @override\n  List<Object?> get props =>\n      [columns, rows, localeText, decoration, selectWithOneTap];\n}\n\nclass TableLocaleText extends Equatable {\n  final String noRows;\n\n  const TableLocaleText({this.noRows = \"No rows to display\"});\n\n  TableLocaleText copyWith({String? noRows}) {\n    return TableLocaleText(noRows: noRows ?? this.noRows);\n  }\n\n  @override\n  List<Object?> get props => [noRows];\n}\n\n@immutable\nclass TableDecoration extends Equatable {\n  final bool enableWrapper;\n  final CardDecoration? wrapperDecoration;\n  final bool isVerticalBorderVisible;\n  final bool isHorizontalBorderVisible;\n  final Color? checkedRowColor;\n  final Color? idleRowColor;\n  final Color? gridBackgroundColor;\n  final Color? gridBorderColor;\n  final TextStyle? columnTextStyle;\n  final TextStyle? cellTextStyle;\n  final Icon? sortAscendingIcon;\n  final Icon? sortDescendingIcon;\n  final double? defaultColumnHeight;\n  final double? defaultRowHeight;\n\n  /// If [cellWidget] is null, this padding will be used\n  ///\n  /// If [cellWidget] is not null, the padding will be set to zero\n  final EdgeInsets? defaultCellPadding;\n  final EdgeInsets? defaultColumnTitlePadding;\n  final Color? evenRowColor;\n  final Color? oddRowColor;\n  final bool enableHeader;\n  final bool enableFooter;\n\n  const TableDecoration({\n    this.wrapperDecoration,\n    this.isVerticalBorderVisible = false,\n    this.isHorizontalBorderVisible = true,\n    this.checkedRowColor,\n    this.idleRowColor,\n    this.gridBackgroundColor,\n    this.gridBorderColor,\n    this.columnTextStyle,\n    this.cellTextStyle,\n    this.sortAscendingIcon,\n    this.sortDescendingIcon,\n    this.defaultColumnHeight,\n    this.defaultRowHeight,\n    this.defaultCellPadding,\n    this.defaultColumnTitlePadding,\n    this.evenRowColor,\n    this.oddRowColor,\n    this.enableHeader = true,\n    this.enableFooter = true,\n    this.enableWrapper = true,\n  });\n\n  @override\n  List<Object?> get props => [\n        wrapperDecoration,\n        isVerticalBorderVisible,\n        isHorizontalBorderVisible,\n        checkedRowColor,\n        idleRowColor,\n        gridBackgroundColor,\n        gridBorderColor,\n        columnTextStyle,\n        cellTextStyle,\n        sortAscendingIcon,\n        sortDescendingIcon,\n        defaultColumnHeight,\n        defaultRowHeight,\n        defaultCellPadding,\n        defaultColumnTitlePadding,\n        evenRowColor,\n        oddRowColor,\n        enableHeader,\n        enableFooter,\n      ];\n}\n\nclass DefaultTable extends StatefulWidget {\n  const DefaultTable({super.key, required this.vm});\n\n  final TableVm vm;\n\n  @override\n  State<DefaultTable> createState() => _DefaultTableState();\n}\n\nclass _DefaultTableState extends State<DefaultTable> {\n  TableVm get vm => widget.vm;\n\n  TableDecoration get decoration => vm.decoration;\n\n  late final PlutoGridStateManager stateManager;\n\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addPostFrameCallback((_) {});\n  }\n\n  PlutoGridConfiguration getConfig(ThemeVm themeVm) {\n    final bool isDarkMode = themeVm.themeMode == ThemeMode.dark;\n    final theme = themeVm.theme;\n\n    PlutoGridColumnSizeConfig sizeConfig() {\n      return const PlutoGridColumnSizeConfig(\n        autoSizeMode: PlutoAutoSizeMode.scale,\n      );\n    }\n\n    //Decoration related settings\n    PlutoGridStyleConfig getStyle(ThemeData theme) {\n      final borderColor =\n          decoration.gridBorderColor ?? Colors.grey.withOpacity(.1);\n      if (isDarkMode) {\n        return PlutoGridStyleConfig.dark(\n          // gridBorderRadius: decoration.wrapperDecoration.borderRadius,//todo:\n          gridBorderColor: borderColor,\n          borderColor: borderColor,\n          inactivatedBorderColor: borderColor,\n          enableCellBorderHorizontal: decoration.isHorizontalBorderVisible,\n          enableCellBorderVertical: decoration.isVerticalBorderVisible,\n          enableColumnBorderHorizontal: decoration.isHorizontalBorderVisible,\n          enableColumnBorderVertical: decoration.isVerticalBorderVisible,\n          rowColor:\n              decoration.idleRowColor ?? theme.dividerColor.withOpacity(.5),\n          checkedColor: decoration.checkedRowColor ??\n              theme.colorScheme.primary.withOpacity(.1),\n          activatedBorderColor: theme.colorScheme.primary,\n          gridBackgroundColor: decoration.gridBackgroundColor ??\n              theme.dividerColor.withOpacity(.5),\n          activatedColor: decoration.gridBackgroundColor ??\n              theme.dividerColor.withOpacity(.5),\n          columnTextStyle: decoration.columnTextStyle ??\n              theme.textTheme.titleSmall!.copyWith(\n                  color: theme.colorScheme.onSurface.withOpacity(0.5)),\n          cellTextStyle:\n              decoration.cellTextStyle ?? theme.textTheme.bodyMedium!,\n          columnAscendingIcon: decoration.sortAscendingIcon ??\n              const Icon(Icons.keyboard_arrow_up_outlined),\n          columnDescendingIcon: decoration.sortDescendingIcon ??\n              const Icon(Icons.keyboard_arrow_down_outlined),\n          columnHeight: decoration.defaultColumnHeight ?? 42.h,\n          rowHeight: decoration.defaultRowHeight ?? 42.h,\n          defaultColumnTitlePadding: decoration.defaultColumnTitlePadding ??\n              EdgeInsets.symmetric(horizontal: 16.w),\n          defaultCellPadding: decoration.defaultCellPadding ??\n              EdgeInsets.symmetric(horizontal: 16.w),\n          evenRowColor: decoration.evenRowColor,\n          oddRowColor: decoration.oddRowColor,\n        );\n      }\n      return PlutoGridStyleConfig(\n        // gridBorderRadius: decoration.wrapperDecoration.borderRadius, //todo:\n        gridBorderColor: borderColor,\n        borderColor: borderColor,\n        inactivatedBorderColor: borderColor,\n        enableCellBorderHorizontal: decoration.isHorizontalBorderVisible,\n        enableCellBorderVertical: decoration.isVerticalBorderVisible,\n        enableColumnBorderHorizontal: decoration.isHorizontalBorderVisible,\n        enableColumnBorderVertical: decoration.isVerticalBorderVisible,\n        rowColor: decoration.idleRowColor ?? theme.colorScheme.surface,\n        checkedColor: decoration.checkedRowColor ??\n            theme.colorScheme.primary.withOpacity(.1),\n        activatedBorderColor: theme.colorScheme.primary,\n        gridBackgroundColor:\n            decoration.gridBackgroundColor ?? theme.colorScheme.surface,\n        activatedColor:\n            decoration.gridBackgroundColor ?? theme.colorScheme.surface,\n        columnTextStyle: decoration.columnTextStyle ??\n            theme.textTheme.titleSmall!\n                .copyWith(color: theme.colorScheme.onSurface.withOpacity(0.5)),\n        cellTextStyle: decoration.cellTextStyle ?? theme.textTheme.bodyMedium!,\n        columnAscendingIcon: decoration.sortAscendingIcon ??\n            const Icon(Icons.keyboard_arrow_up_outlined),\n        columnDescendingIcon: decoration.sortDescendingIcon ??\n            const Icon(Icons.keyboard_arrow_down_outlined),\n        columnHeight: decoration.defaultColumnHeight ?? 42.h,\n        rowHeight: decoration.defaultRowHeight ?? 42.h,\n        defaultColumnTitlePadding: decoration.defaultColumnTitlePadding ??\n            EdgeInsets.symmetric(horizontal: 16.w),\n        defaultCellPadding: decoration.defaultCellPadding ??\n            EdgeInsets.symmetric(horizontal: 16.w),\n        evenRowColor: decoration.evenRowColor,\n        oddRowColor: decoration.oddRowColor,\n      );\n    }\n\n    PlutoGridScrollbarConfig getScrollbar(ThemeData theme) {\n      return const PlutoGridScrollbarConfig();\n    }\n\n    if (isDarkMode) {\n      return PlutoGridConfiguration.dark(\n        columnSize: sizeConfig(),\n        style: getStyle(theme),\n        scrollbar: getScrollbar(theme),\n      );\n    }\n\n    return PlutoGridConfiguration(\n      columnSize: sizeConfig(),\n      style: getStyle(theme),\n      scrollbar: getScrollbar(theme),\n    );\n  }\n\n  Widget getNoRowsWidget(ThemeData theme) {\n    return Center(\n      child: Text(\n        vm.localeText.noRows,\n        style: theme.textTheme.bodyLarge!.copyWith(\n          color: theme.colorScheme.onSurface.withOpacity(0.4),\n        ),\n      ),\n    );\n  }\n\n  Widget getTable(ThemeVm themeVm) {\n    final theme = themeVm.theme;\n    return SizedBox(\n      width: double.infinity,\n      height: 700,\n      child: Theme(\n        data: theme,\n        child: PlutoGrid(\n          configuration: getConfig(themeVm),\n          createHeader: decoration.enableHeader\n              ? (stateManager) => _Header(stateManager: stateManager)\n              : null,\n          createFooter: decoration.enableFooter\n              ? (stateManager) => _Footer(stateManager: stateManager)\n              : null,\n          mode: PlutoGridMode.selectWithOneTap,\n          onSelected: (event) {\n            if (vm.selectWithOneTap) {\n              if (event.row != null) {\n                if (event.row!.checked != null) {\n                  stateManager.setRowChecked(event.row!, !event.row!.checked!);\n                }\n              }\n            }\n          },\n          noRowsWidget: getNoRowsWidget(theme),\n          columns: vm.columns.map((e) => e.plutoColumn).toList(),\n          rows: vm.rows.map((e) => e.plutoRow).toList(),\n          onLoaded: handleOnLoadedEvent,\n        ),\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ThemeProvider(builder: (context, themeVm) {\n      if (vm.decoration.enableWrapper) {\n        return getTable(themeVm);\n      } else {\n        return getTable(themeVm);\n      }\n    });\n  }\n\n  void handleOnLoadedEvent(PlutoGridOnLoadedEvent event) {\n    this.stateManager = event.stateManager;\n    final stateManager = event.stateManager;\n\n    stateManager.setPageSize(10);\n    stateManager.addListener(() {\n      setState(() {});\n    });\n    stateManager.keyManager!.eventResult.skip(KeyEventResult.ignored);\n    vm.getTableController(TableController(\n      columns: vm.columns,\n      rows: vm.rows,\n      onAddRows: (row) {\n        stateManager.appendRows(row.map((e) => e.plutoRow).toList());\n      },\n      onRemoveRows: (rows) {\n        stateManager.removeRows(rows.map((e) => e.plutoRow).toList());\n      },\n      getSelectedRows: () {\n        return stateManager.checkedRows.map((e) => e.toDefaultRow()).toList();\n      },\n      onSortBy: (column, {isAscending}) {\n        if (isAscending == null) {\n          if (column.plutoColumn.sort.isAscending) {\n            stateManager.sortDescending(column.plutoColumn);\n          } else {\n            stateManager.sortAscending(column.plutoColumn);\n          }\n        } else {\n          if (isAscending) {\n            stateManager.sortAscending(column.plutoColumn);\n          } else {\n            stateManager.sortDescending(column.plutoColumn);\n          }\n        }\n      },\n      onClearSort: () {\n        final column = stateManager.getSortedColumn;\n        if (column != null) {\n          //if ascending, toggle 2 times to clear\n          //if descending, toggle 1 time to clear\n          if (column.sort.isAscending) {\n            stateManager.toggleSortColumn(column);\n            stateManager.toggleSortColumn(column);\n          } else {\n            stateManager.toggleSortColumn(column);\n          }\n        }\n      },\n      onSelectAll: () {\n        stateManager.toggleAllRowChecked(true);\n      },\n      onUnselectAll: () {\n        stateManager.toggleAllRowChecked(false);\n      },\n      onToggleSelectAll: () {\n        if (stateManager.hasCheckedRow) {\n          stateManager.toggleAllRowChecked(false);\n        } else {\n          stateManager.toggleAllRowChecked(true);\n        }\n      },\n      onHideColumn: (column) {\n        stateManager.hideColumn(column.plutoColumn, true);\n      },\n      onShowColumn: (column) {\n        stateManager.hideColumn(column.plutoColumn, false);\n      },\n      onToggleColumnVisibility: (column) {\n        stateManager.hideColumn(column.plutoColumn, !column.plutoColumn.hide);\n      },\n    ));\n    setState(() {});\n  }\n}\n\nclass _Header extends StatefulWidget {\n  final PlutoGridStateManager stateManager;\n\n  const _Header({required this.stateManager});\n\n  @override\n  State<_Header> createState() => _HeaderState();\n}\n\nclass _HeaderState extends State<_Header> {\n  PlutoGridStateManager get stateManager => widget.stateManager;\n  FocusNode focusNode = FocusNode();\n\n  final List<PlutoColumn> columns = [];\n\n  @override\n  void initState() {\n    columns.addAll(stateManager.columns);\n    setState(() {});\n    super.initState();\n    focusNode = FocusNode(onKey: (node, event) {\n      if (event is RawKeyUpEvent) {\n        return KeyEventResult.handled;\n      }\n      return stateManager.keyManager!.eventResult.skip(KeyEventResult.ignored);\n    });\n  }\n\n  @override\n  void dispose() {\n    stateManager.gridFocusNode.removeListener(handleFocus);\n    focusNode.dispose();\n    super.dispose();\n  }\n\n  void handleFocus() {\n    stateManager.setKeepFocus(!focusNode.hasFocus);\n  }\n\n  PopupMenuThemeData getPopupMenuTheme(ThemeData theme) {\n    return PopupMenuThemeData(\n      position: PopupMenuPosition.under,\n      surfaceTintColor: theme.colorScheme.primary,\n      elevation: 2,\n      labelTextStyle: MaterialStateProperty.resolveWith((states) {\n        //if disabled\n        if (states.contains(MaterialState.disabled)) {\n          return theme.textTheme.bodyMedium!.copyWith(\n            color: theme.colorScheme.onSurface.withOpacity(0.5),\n          );\n        }\n        return theme.textTheme.bodyMedium!;\n      }),\n      enableFeedback: false,\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ThemeProvider(builder: (context, themeVm) {\n      final theme = themeVm.theme;\n      return Theme(\n        data: theme.copyWith(\n          popupMenuTheme: getPopupMenuTheme(theme),\n        ),\n        child: SizedBox(\n          height: 70,\n          child: Padding(\n            padding: const EdgeInsets.all(10).w,\n            child: Row(\n              mainAxisAlignment: MainAxisAlignment.spaceBetween,\n              children: [\n                // search field\n                SizedBox(\n                    height: double.maxFinite,\n                    width: MediaQuery.sizeOf(context).width * 0.3,\n                    child: DefaultInput(\n                        decorationBuilder: (context) => InputDecor(context,\n                            child: InputChild(context,\n                                name: \"table_search\", hintText: \"Filter\"),\n                            state: InputState(context, focusNode: focusNode),\n                            action: InputAction(context, onChanged: (value) {\n                              try {\n                                stateManager.setFilter((element) =>\n                                    element.cells.values.any((cell) => cell\n                                        .value\n                                        .toString()\n                                        .toLowerCase()\n                                        .contains(value!.toLowerCase())) ==\n                                    true);\n                              } catch (e) {\n                                debugPrint(e.toString());\n                              }\n                            })))).w,\n\n                SizedBox(\n                  width: MediaQuery.sizeOf(context).width * 0.3,\n                  child: DefaultSelect<PlutoColumn>(\n                    form: const SelectForm(name: \"columns\"),\n                    decoration: SelectDecoration(\n                      showSelectedValuesContent: false,\n                      labelText: \"Columns\",\n                      hintText: columns.length == stateManager.columns.length\n                          ? \"All\"\n                          : columns.every((element) => element.hide)\n                              ? \"None\"\n                              : \"${columns.where((element) => element.hide == false).length} selected\",\n                      selectionType: SelectionType.multi,\n                    ),\n                    options: SelectOptions(\n                      onOptionRemoved: (index, option) {\n                        if (option.value != null) {\n                          stateManager.hideColumn(option.value!, true);\n                        }\n                      },\n                      onOptionSelected: (selectedOptions) {\n                        if (selectedOptions.isNotEmpty) {\n                          for (var col in selectedOptions) {\n                            if (col.value != null) {\n                              stateManager.hideColumn(col.value!, false);\n                            }\n                          }\n                        }\n                      },\n                      selectedOptions: [\n                        for (var col in columns)\n                          ValueItem(\n                            label: col.title,\n                            value: col,\n                          )\n                      ],\n                      options: [\n                        for (var col in columns)\n                          ValueItem(\n                            label: col.title,\n                            value: col,\n                          )\n                      ],\n                    ),\n                  ),\n                )\n              ],\n            ),\n          ),\n        ).w,\n      );\n    });\n  }\n}\n\nclass _Footer extends StatefulWidget {\n  final PlutoGridStateManager stateManager;\n  const _Footer({\n    required this.stateManager,\n  });\n\n  @override\n  State<_Footer> createState() => __Footer();\n}\n\nclass __Footer extends State<_Footer> {\n  PlutoGridStateManager get stateManager => widget.stateManager;\n\n  int pageNumber = 1;\n  int pageSize = 10;\n\n  @override\n  void initState() {\n    super.initState();\n    stateManager.setPage(pageNumber);\n    stateManager.setPageSize(pageSize);\n    setState(() {});\n    stateManager.addListener(() {\n      if (mounted) {\n        setState(() {\n          pageNumber = stateManager.page;\n          pageSize = stateManager.pageSize;\n        });\n      }\n    });\n  }\n\n  void changePageSize(int size) {\n    setState(() {\n      pageSize = size;\n    });\n    stateManager.setPageSize(size);\n    stateManager.setPage(1);\n  }\n\n  void changePageNumber(int number) {\n    setState(() {\n      pageNumber = number;\n    });\n    stateManager.setPage(number);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    //\"Total ${(stateManager.rows.length * stateManager.totalPage).toString()} rows\"),\n    return SizedBox(\n      height: 70.h,\n      child: Padding(\n        padding: const EdgeInsets.all(10.0),\n        child: Row(\n          mainAxisAlignment: MainAxisAlignment.spaceBetween,\n          children: [\n            //Page size changer\n            SizedBox(\n              width: MediaQuery.sizeOf(context).width * 0.2,\n              child: DefaultSelect<int>(\n                form: const SelectForm(name: \"table_page_size\"),\n                decoration: const SelectDecoration(labelText: 'Rows per page'),\n                options: SelectOptions(\n                  onOptionSelected: (newList) {\n                    if (newList.isNotEmpty) {\n                      changePageSize(newList.first.value!);\n                    }\n                  },\n                  options: [\n                    for (var ps in [10, 50, 100])\n                      ValueItem(\n                        label: ps.toString(),\n                        value: ps,\n                      )\n                  ],\n                  selectedOptions: [\n                    ValueItem(\n                        label: \"${stateManager.pageSize}\",\n                        value: stateManager.pageSize)\n                  ],\n                ),\n              ),\n            ),\n\n            //Page number\n            DefaultPagination(decorationBuilder: (context) {\n              return PaginationDecoration(context,\n                  action: PaginationAction(context,\n                      onPageChanged: changePageNumber),\n                  value: PaginationValue(context,\n                      totalPages: stateManager.totalPage,\n                      currentPage: stateManager.page));\n            }),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  },
  {
    "name": "with_label",
    "version": "0.0.1",
    "dependencies": [
      "label"
    ],
    "content": "//v0.0.1\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nimport 'label.dart';\n\nexport 'label.dart';\n\nclass WithLabel extends StatelessWidget {\n  final LabelDecorationBuilder labelBuilder;\n  final Widget child;\n  const WithLabel({super.key, required this.labelBuilder, required this.child});\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      mainAxisSize: MainAxisSize.min,\n      children: [\n        Label(decorationBuilder: labelBuilder),\n        child,\n      ],\n    ).spaced(4);\n  }\n}\n"
  },
  {
    "name": "dropdown",
    "version": "0.0.1",
    "dependencies": [
      "input",
      "dp_item"
    ],
    "content": "import 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nimport 'form.dart';\nimport 'input.dart';\nimport 'disabled.dart';\nimport 'dp_item.dart';\n\nclass DropdownItem extends Equatable {\n  final String? groupTitle;\n  final IconData? groupIcon;\n  final List<DpItem> items;\n\n  const DropdownItem({\n    this.groupTitle,\n    required this.items,\n    this.groupIcon,\n  });\n\n  @override\n  List<Object?> get props => [groupTitle, items, groupIcon];\n\n//copyWith\n  DropdownItem copyWith({\n    String? groupTitle,\n    IconData? groupIcon,\n    List<DpItem>? items,\n  }) {\n    return DropdownItem(\n      groupTitle: groupTitle ?? this.groupTitle,\n      groupIcon: groupIcon ?? this.groupIcon,\n      items: items ?? this.items,\n    );\n  }\n}\n\nclass DropdownVariant extends IFormModel {\n  final DpForm form;\n  final DpDecoration decoration;\n  final List<String> disabledItems;\n\n  const DropdownVariant({\n    required super.name,\n    this.disabledItems = const [],\n    required this.form,\n    this.decoration = const DpDecoration(),\n  });\n\n  @override\n  List<Object?> get props => [name, form, decoration, disabledItems];\n}\n\nclass DpForm extends Equatable {\n  final List<DropdownItem> items;\n\n  ///If null, then disabled\n  final void Function(String?)? onChanged;\n\n  final String? initialValue;\n  final String? Function(String?)? validator;\n  final AutovalidateMode? autovalidateMode;\n\n  DpForm({\n    required this.items,\n    this.onChanged,\n    this.initialValue,\n    this.validator,\n    this.autovalidateMode,\n  })  :\n//assert if items has same id\n        assert(\n            items\n                    .expand((element) => element.items)\n                    .map((e) => e.id)\n                    .toSet()\n                    .length ==\n                items\n                    .expand((element) => element.items)\n                    .map((e) => e.id)\n                    .length,\n            \"Items id must be unique\"),\n//assert if items has at least one item\n        assert(items.isNotEmpty, \"Items cannot be empty\");\n\n  @override\n  List<Object?> get props =>\n      [items, onChanged, initialValue, validator, autovalidateMode];\n}\n\nclass DpDecoration extends Equatable {\n  final String? hintText;\n  final IconData? icon;\n  final Color? selectedColor;\n  final Color? hoverColor;\n  final String? searchHintText;\n  final Color? backgroundColor;\n  final Color? foregroundColor;\n  final String? helperText;\n  final bool hasSearchBox;\n  final bool hasBorder;\n  final Widget? customWidget;\n  final double? defaultMenuItemWidth;\n\n  const DpDecoration({\n    this.hintText,\n    this.icon,\n    this.backgroundColor,\n    this.selectedColor,\n    this.hoverColor,\n    this.searchHintText,\n    this.foregroundColor,\n    this.helperText,\n    this.hasSearchBox = false,\n    this.customWidget,\n    this.hasBorder = true,\n    this.defaultMenuItemWidth,\n  });\n\n  @override\n  List<Object?> get props => [\n        hintText,\n        icon,\n        selectedColor,\n        hoverColor,\n        searchHintText,\n        backgroundColor,\n        foregroundColor,\n        helperText,\n        hasSearchBox,\n        customWidget,\n        hasBorder,\n        defaultMenuItemWidth,\n      ];\n}\n\nclass DefaultDropdown extends StatelessWidget {\n  final DropdownVariant variant;\n\n  const DefaultDropdown({super.key, required this.variant});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultDisabled(\n        decorationBuilder: (themeVm) => DisabledDecoration(themeVm,\n            state: DisabledState(themeVm,\n                isDisabled: variant.form.onChanged == null),\n            child: DisabledChild(themeVm,\n                child: FormBuilderField<String>(\n                    name: variant.name,\n                    validator: variant.form.validator,\n                    initialValue: variant.form.initialValue,\n                    onChanged: variant.form.onChanged,\n                    autovalidateMode: variant.form.autovalidateMode,\n                    enabled: variant.form.onChanged != null,\n                    builder: (FormFieldState<String> state) {\n                      return _DropdownSelect(state: state, variant: variant);\n                    }))));\n  }\n}\n\nclass _DropdownSelect extends StatefulWidget {\n  final FormFieldState<String>? state;\n  final DropdownVariant variant;\n\n  const _DropdownSelect({this.state, required this.variant});\n\n  @override\n  State<_DropdownSelect> createState() => __DropdownSelectState();\n}\n\nclass __DropdownSelectState extends State<_DropdownSelect> {\n  final TextEditingController searchController = TextEditingController();\n\n  DropdownVariant get variant => widget.variant;\n\n  FormFieldState<String>? get state => widget.state;\n\n  String? get errorText => state?.errorText;\n\n  DpItem? get selectedItem => variant.form.items\n      .expand((element) => element.items)\n      .firstWhereOrNull((element) => element.id == state?.value);\n\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addPostFrameCallback((timeStamp) {\n      if (variant.form.initialValue != null) {\n        state?.didChange(variant.form.initialValue);\n      }\n    });\n  }\n\n  @override\n  void dispose() {\n    searchController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final bool isError = state?.hasError == true;\n    final String? errorText = state?.errorText;\n    return ThemeProvider(builder: (context, themeVm) {\n      final ThemeData theme = themeVm.theme;\n      return Theme(\n        data: theme,\n        child: DropdownButtonFormField2<DpItem>(\n          items: _getItems(themeVm.theme),\n          value: selectedItem,\n          hint: variant.decoration.hintText != null\n              ? Text(\n                  variant.decoration.hintText!,\n                  overflow: TextOverflow.ellipsis,\n                  style: theme.textTheme.bodyMedium!.copyWith(\n                      fontWeight: FontWeight.normal,\n                      color: variant.decoration.foregroundColor ??\n                          theme.colorScheme.onSurface.withOpacity(0.4)),\n                )\n              : null,\n          dropdownSearchData: variant.decoration.hasSearchBox\n              ? DropdownSearchData(\n                  searchController: searchController,\n                  searchInnerWidget: Padding(\n                      padding:\n                          const EdgeInsets.only(left: 8, right: 8, top: 8).w,\n                      child: DefaultInput(\n                          decorationBuilder: (themeVm) => InputDecor(themeVm,\n                              child: InputChild(themeVm,\n                                  name: \"${variant.name}Search\",\n                                  hintText: variant.decoration.searchHintText ??\n                                      \"Search\"),\n                              value: InputValue(themeVm,\n                                  controller: searchController)))),\n                  searchMatchFn: (item, searchValue) {\n                    bool found = false;\n                    if (item.value?.title\n                            .toLowerCase()\n                            .contains(searchValue.toLowerCase()) ??\n                        false) {\n                      found = true;\n                    } else {\n                      if (item.value?.subtitle\n                              ?.toLowerCase()\n                              .contains(searchValue.toLowerCase()) ??\n                          false) {\n                        found = true;\n                      }\n                    }\n                    return found;\n                  },\n                  searchInnerWidgetHeight: 36.h,\n                )\n              : null,\n          decoration: InputDecoration(\n              filled: false,\n              errorText: isError ? errorText : null,\n              errorStyle:\n                  theme.textTheme.bodyMedium!.copyWith(color: Colors.red),\n              hoverColor: Colors.transparent,\n              helperText: variant.decoration.helperText,\n              helperStyle: theme.textTheme.bodySmall!.copyWith(\n                  color: theme.colorScheme.onSurface.withOpacity(0.4))),\n          onChanged: variant.form.onChanged == null\n              ? null\n              : (value) {\n                  state?.didChange(value?.id);\n                },\n          customButton: variant.decoration.customWidget,\n          dropdownStyleData: _getDropdownStyle(theme),\n          iconStyleData: _getIconStyle(theme),\n          menuItemStyleData: _getMenuItemStyle(theme),\n          selectedItemBuilder: (context) {\n            return _getItems(theme).map((e) {\n              return RichText(\n                overflow: TextOverflow.ellipsis,\n                text: TextSpan(children: [\n                  TextSpan(\n                      text: selectedItem?.title,\n                      style: theme.textTheme.bodyLarge!\n                          .copyWith(color: variant.decoration.foregroundColor)),\n                ]),\n              );\n            }).toList();\n          },\n          buttonStyleData: ButtonStyleData(\n            elevation: 0,\n            overlayColor: MaterialStateProperty.resolveWith((states) {\n              return Colors.transparent;\n            }),\n          ),\n        ),\n      );\n    });\n  }\n\n  IconStyleData _getIconStyle(ThemeData theme) {\n    return IconStyleData(\n      icon: Padding(\n        padding: const EdgeInsets.only(right: 16.0).w,\n        child: Icon(\n          variant.decoration.icon ?? Icons.unfold_more,\n          color: variant.decoration.foregroundColor ??\n              theme.colorScheme.onSurface.withOpacity(0.6),\n          size: 16.w,\n        ),\n      ),\n    );\n  }\n\n  DropdownStyleData _getDropdownStyle(ThemeData theme) {\n    final shadows = [\n      BoxShadow(\n        offset: const Offset(0, 2).w,\n        color: Colors.black.withOpacity(0.08),\n        blurRadius: 4.w,\n        spreadRadius: 0,\n      ),\n      BoxShadow(\n        offset: const Offset(0, 4).w,\n        color: Colors.black.withOpacity(0.1),\n        blurRadius: 10.w,\n        spreadRadius: 0,\n      ),\n    ];\n    return DropdownStyleData(\n      maxHeight: 300.h,\n      width: variant.decoration.defaultMenuItemWidth?.w,\n      padding: const EdgeInsets.all(8).w,\n      elevation: 0,\n      offset: const Offset(0, -4).w,\n      decoration: BoxDecoration(\n        boxShadow: shadows,\n        border: Border.all(\n          color: theme.dividerColor.withOpacity(0.6),\n          width: 1.w,\n        ),\n        borderRadius: BorderRadius.circular(4).r,\n      ),\n    );\n  }\n\n  MenuItemStyleData _getMenuItemStyle(ThemeData theme) {\n    return MenuItemStyleData(\n        overlayColor: MaterialStateProperty.resolveWith((states) {\n          if (states.contains(MaterialState.hovered)) {\n            return variant.decoration.hoverColor ??\n                variant.decoration.backgroundColor ??\n                theme.dividerColor.withOpacity(0.2);\n          }\n          return null;\n        }),\n        selectedMenuItemBuilder: (context, child) {\n          return DecoratedBox(\n            decoration: BoxDecoration(\n              color: variant.decoration.selectedColor ??\n                  variant.decoration.backgroundColor ??\n                  theme.dividerColor.withOpacity(0.4),\n              borderRadius: BorderRadius.circular(4).r,\n            ),\n            child: child,\n          );\n        },\n        padding: const EdgeInsets.all(0).w,\n        customHeights: _getCustomHeights());\n  }\n\n  List<double> _getCustomHeights() {\n    final List<double> customHeights = [];\n//if has group title => 35\n//if has subtitle => 50\n//if has only title => 35\n    for (final groupItem in variant.form.items) {\n      if (groupItem.groupTitle != null) {\n        customHeights.add(35.h);\n      }\n      for (final item in groupItem.items) {\n        if (item.subtitle != null) {\n          customHeights.add(50.h);\n        } else {\n          customHeights.add(35.h);\n        }\n      }\n    }\n    return customHeights;\n  }\n\n  String? hoveringId;\n\n  List<DropdownMenuItem<DpItem>> _getItems(ThemeData theme) {\n    final List<DropdownMenuItem<DpItem>> items = [];\n\n    for (final groupItem in variant.form.items) {\n      if (groupItem.groupTitle != null) {\n        items.add(DropdownMenuItem<DpItem>(\n          value: DpItem(\n              id: \"title${groupItem.groupTitle}\", title: groupItem.groupTitle!),\n          enabled: false,\n          child: Container(\n            margin: const EdgeInsets.symmetric(horizontal: 8).w,\n            child: Row(\n              mainAxisSize: MainAxisSize.min,\n              children: [\n                if (groupItem.groupIcon != null)\n                  Icon(groupItem.groupIcon,\n                      color: theme.colorScheme.onSurface.withOpacity(0.6),\n                      size: 16.w),\n                Text(groupItem.groupTitle!, style: theme.textTheme.titleMedium),\n              ],\n            ).spaced(8),\n          ),\n        ));\n      }\n      for (final item in groupItem.items) {\n        items.add(DropdownMenuItem<DpItem>(\n            value: item,\n            enabled: !variant.disabledItems.contains(item.id),\n            child: DefaultDisabled(\n                decorationBuilder: (themeVm) => DisabledDecoration(themeVm,\n                    state: DisabledState(themeVm,\n                        isDisabled: variant.disabledItems.contains(item.id)),\n                    child: DisabledChild(themeVm,\n                        child: Container(\n                            width: double.infinity,\n                            height: double.infinity,\n                            padding:\n                                const EdgeInsets.symmetric(horizontal: 8).w,\n                            alignment: Alignment.centerLeft,\n                            child: Row(\n                                mainAxisSize: MainAxisSize.min,\n                                crossAxisAlignment: CrossAxisAlignment.center,\n                                children: [\n                                  if (item.icon != null)\n                                    Row(\n                                      mainAxisSize: MainAxisSize.min,\n                                      children: [\n                                        Icon(item.icon,\n                                            color: theme.colorScheme.onSurface\n                                                .withOpacity(0.6),\n                                            size: 16.w),\n                                        const SizedBox(width: 8).w,\n                                      ],\n                                    ),\n                                  Expanded(\n                                      child: Column(\n                                          crossAxisAlignment:\n                                              CrossAxisAlignment.start,\n                                          mainAxisSize: MainAxisSize.min,\n                                          children: [\n                                        Text(item.title,\n                                            maxLines: 1,\n                                            overflow: TextOverflow.ellipsis,\n                                            style: theme.textTheme.bodyMedium),\n                                        if (item.subtitle != null)\n                                          Text(item.subtitle!,\n                                              maxLines: 1,\n                                              overflow: TextOverflow.ellipsis,\n                                              style: theme.textTheme.bodySmall!\n                                                  .copyWith(\n                                                      color: theme\n                                                          .colorScheme.onSurface\n                                                          .withOpacity(0.6)))\n                                      ]))\n                                ])))))));\n      }\n    }\n    return items;\n  }\n}\n"
  }
]