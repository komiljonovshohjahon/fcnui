[
  {
    "name": "button",
    "version": "0.0.1",
    "content": "//v0.0.1\n\nimport 'package:flutter/material.dart';\nimport 'package:fcnui_base/fcnui_base.dart';\n\n/// [ButtonVariant] is the base class for all button variants\n///\n/// Can use these variants:\n/// - [PrimaryButtonVariant]\n/// - [SecondaryButtonVariant]\n/// - [TertiaryButtonVariant]\n/// - [ErrorButtonVariant]\n/// - [OutlineButtonVariant]\n/// - [GhostButtonVariant]\nabstract class ButtonVariant extends Equatable {\n  /// If [onPressed] is null, the button will be disabled\n  final VoidCallback? onPressed;\n\n  final String? text;\n\n  /// If [child] is provided, [text] will be ignored\n  ///\n  /// [child] will be used as the button's child\n  final Widget? child;\n\n  /// If true, it will show a loading indicator\n  ///\n  /// If [icon] is provided, icon will be replaced with loading indicator\n  ///\n  /// [onPressed] will be disabled if [isLoading] is true\n  final bool isLoading;\n\n  /// Icon of the button\n  ///\n  /// If [isLoading] is true, icon will be replaced with loading indicator\n  final IconData? icon;\n\n  /// Size of the icon\n  ///\n  /// Default is 18px\n  final double iconSize;\n\n  /// Minimum size of the button\n  ///\n  /// Default is 88px x 40px\n  final Size? minimumSize;\n\n  ///Custom background color\n  ///\n  /// It will override the default background color if provided\n  final Color? backgroundColor;\n\n  ///Custom foreground color\n  ///\n  /// It will override the default foreground color if provided\n  final Color? foregroundColor;\n\n  const ButtonVariant(\n      {this.onPressed,\n      this.text,\n      this.backgroundColor,\n      this.foregroundColor,\n      this.iconSize = 18,\n      this.child,\n      this.isLoading = false,\n      this.minimumSize,\n      this.icon})\n      : assert(iconSize >= 0, \"iconSize must be greater than or equal to 0\"),\n        assert(text != null || child != null || icon != null,\n            \"text, child, or icon must be provided\");\n\n  @override\n  List<Object?> get props => [\n        onPressed,\n        text,\n        child,\n        isLoading,\n        icon,\n        iconSize,\n        minimumSize,\n        backgroundColor,\n        foregroundColor,\n      ];\n}\n\nclass PrimaryButtonVariant extends ButtonVariant {\n  const PrimaryButtonVariant(\n      {super.onPressed,\n      super.text,\n      super.child,\n      super.isLoading,\n      super.icon,\n      super.iconSize,\n      super.minimumSize,\n      super.backgroundColor,\n      super.foregroundColor});\n}\n\nclass SecondaryButtonVariant extends ButtonVariant {\n  const SecondaryButtonVariant(\n      {super.onPressed,\n      super.text,\n      super.child,\n      super.isLoading,\n      super.icon,\n      super.iconSize,\n      super.minimumSize,\n      super.backgroundColor,\n      super.foregroundColor});\n}\n\nclass TertiaryButtonVariant extends ButtonVariant {\n  const TertiaryButtonVariant(\n      {super.onPressed,\n      super.text,\n      super.child,\n      super.isLoading,\n      super.icon,\n      super.iconSize,\n      super.minimumSize,\n      super.backgroundColor,\n      super.foregroundColor});\n}\n\nclass ErrorButtonVariant extends ButtonVariant {\n  const ErrorButtonVariant(\n      {super.onPressed,\n      super.text,\n      super.child,\n      super.isLoading,\n      super.icon,\n      super.iconSize,\n      super.minimumSize,\n      super.backgroundColor,\n      super.foregroundColor});\n}\n\nclass OutlineButtonVariant extends ButtonVariant {\n  const OutlineButtonVariant(\n      {super.onPressed,\n      super.text,\n      super.child,\n      super.isLoading,\n      super.icon,\n      super.iconSize,\n      super.minimumSize,\n      super.backgroundColor,\n      super.foregroundColor});\n}\n\nclass GhostButtonVariant extends ButtonVariant {\n  const GhostButtonVariant(\n      {super.onPressed,\n      super.text,\n      super.child,\n      super.isLoading,\n      super.icon,\n      super.iconSize,\n      super.minimumSize,\n      super.backgroundColor,\n      super.foregroundColor});\n}\n\nclass IconButtonVariant extends ButtonVariant {\n  const IconButtonVariant(\n      {super.onPressed,\n      super.child,\n      super.isLoading,\n      required super.icon,\n      super.iconSize,\n      super.minimumSize,\n      super.backgroundColor,\n      super.foregroundColor});\n}\n\nclass DefaultButton extends StatelessWidget {\n  final ButtonVariant variant;\n\n  const DefaultButton({super.key, required this.variant});\n\n  @override\n  Widget build(BuildContext context) {\n    return ThemeProvider(\n      builder: (context, vm) {\n        return getChild(vm);\n      },\n    );\n  }\n\n  Widget getChild(ThemeVm vm) {\n    return Theme(\n        data: vm.theme.copyWith(\n          elevatedButtonTheme: ElevatedButtonThemeData(\n            style: _getButtonStyle(vm.theme),\n          ),\n          textButtonTheme: TextButtonThemeData(\n            style: _getButtonStyle(vm.theme),\n          ),\n          iconButtonTheme: IconButtonThemeData(\n            style: _getButtonStyle(vm.theme),\n          ),\n        ),\n        child: _getButtonWidgetType(vm.theme));\n  }\n\n  ButtonStyle _getIconButtonStyle(ThemeData theme) {\n    return IconButton.styleFrom(\n      padding: _getPadding(theme),\n      minimumSize: variant.minimumSize?.w,\n      disabledMouseCursor: SystemMouseCursors.forbidden,\n      splashFactory: NoSplash.splashFactory,\n      backgroundColor: _getBackgroundColor(theme),\n      foregroundColor: _getForegroundColor(theme),\n    );\n  }\n\n  ButtonStyle _getButtonStyle(ThemeData theme) {\n    if (variant is IconButtonVariant) {\n      return _getIconButtonStyle(theme);\n    }\n    return ElevatedButton.styleFrom(\n      disabledBackgroundColor: _getBackgroundColor(theme)?.withOpacity(0.5),\n      disabledForegroundColor: _getForegroundColor(theme)?.withOpacity(0.5),\n      backgroundColor: _getBackgroundColor(theme),\n      foregroundColor: _getForegroundColor(theme),\n      shape: _getShape(theme),\n      side: _getBorder(theme),\n      padding: _getPadding(theme),\n      minimumSize: variant.minimumSize?.w,\n      splashFactory: NoSplash.splashFactory,\n      disabledMouseCursor: SystemMouseCursors.forbidden,\n      surfaceTintColor: theme.colorScheme.surface,\n      textStyle: _getTextStyle(theme),\n    );\n  }\n\n  TextStyle _getTextStyle(ThemeData theme) {\n    return theme.textTheme.bodyMedium!.sp;\n  }\n\n  EdgeInsetsGeometry _getPadding(ThemeData theme) {\n    switch (variant.runtimeType) {\n      default:\n        return const EdgeInsets.symmetric(horizontal: 16, vertical: 8).w;\n    }\n  }\n\n  Widget _getButtonWidgetType(ThemeData theme) {\n    switch (variant.runtimeType) {\n      case const (PrimaryButtonVariant):\n      case const (SecondaryButtonVariant):\n      case const (TertiaryButtonVariant):\n      case const (ErrorButtonVariant):\n        if (variant.icon == null) {\n          return ElevatedButton(\n            onPressed: _getOnPressed,\n            child: _getButtonChild(theme),\n          );\n        } else {\n          if (variant.text != null && variant.text!.isNotEmpty) {\n            return ElevatedButton.icon(\n              onPressed: _getOnPressed,\n              label: _getButtonChild(theme),\n              icon: variant.isLoading\n                  ? const _LoadingIndicator()\n                  : Icon(variant.icon, size: variant.iconSize.w),\n            );\n          }\n          return ElevatedButton(\n            onPressed: _getOnPressed,\n            child: variant.isLoading\n                ? const _LoadingIndicator()\n                : Icon(variant.icon, size: variant.iconSize.w),\n          );\n        }\n      case const (OutlineButtonVariant):\n      case const (GhostButtonVariant):\n        if (variant.icon == null) {\n          return TextButton(\n            onPressed: _getOnPressed,\n            child: _getButtonChild(theme),\n          );\n        } else {\n          return TextButton.icon(\n            onPressed: _getOnPressed,\n            label: _getButtonChild(theme),\n            icon: variant.isLoading\n                ? const _LoadingIndicator()\n                : Icon(variant.icon, size: variant.iconSize.w),\n          );\n        }\n      case const (IconButtonVariant):\n        return IconButton(\n          onPressed: _getOnPressed,\n          icon: Icon(variant.icon, size: variant.iconSize.w),\n        );\n      default:\n        return const SizedBox();\n    }\n  }\n\n  VoidCallback? get _getOnPressed {\n    switch (variant.runtimeType) {\n      default:\n        if (variant.isLoading) return null;\n        return variant.onPressed;\n    }\n  }\n\n  Color? _getBackgroundColor(ThemeData theme) {\n    if (variant.backgroundColor != null) return variant.backgroundColor;\n    switch (variant.runtimeType) {\n      case const (PrimaryButtonVariant):\n        return theme.colorScheme.primary;\n      case const (SecondaryButtonVariant):\n        return theme.colorScheme.secondary;\n      case const (TertiaryButtonVariant):\n        return theme.colorScheme.tertiary;\n      case const (ErrorButtonVariant):\n        return theme.colorScheme.error;\n      default:\n        return null;\n    }\n  }\n\n  Color? _getForegroundColor(ThemeData theme) {\n    if (variant.foregroundColor != null) return variant.foregroundColor;\n    switch (variant.runtimeType) {\n      case const (PrimaryButtonVariant):\n      case const (ErrorButtonVariant):\n        return theme.colorScheme.onPrimary;\n      case const (SecondaryButtonVariant):\n        return theme.colorScheme.onSecondary;\n      case const (TertiaryButtonVariant):\n        return theme.colorScheme.onTertiary;\n      case const (OutlineButtonVariant):\n      case const (GhostButtonVariant):\n        return theme.colorScheme.onSurface;\n      default:\n        return null;\n    }\n  }\n\n  Widget _getButtonChild(ThemeData theme) {\n    final ch = variant.child ?? Text(_getText());\n    if (variant.icon == null) {\n      if (variant.isLoading) {\n        return Row(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            const _LoadingIndicator(),\n            ch,\n          ],\n        ).spaced(8);\n      }\n    }\n    return ch;\n  }\n\n  String _getText() {\n    return variant.text ?? 'Button';\n  }\n\n  BorderSide? _getBorder(ThemeData theme) {\n    switch (variant.runtimeType) {\n      case const (OutlineButtonVariant):\n        return BorderSide(color: theme.dividerColor.withOpacity(0.6)).w;\n      default:\n        return null;\n    }\n  }\n\n  OutlinedBorder? _getShape(ThemeData theme) {\n    switch (variant.runtimeType) {\n      default:\n        return RoundedRectangleBorder(\n          borderRadius: BorderRadius.circular(6).r,\n        );\n    }\n  }\n}\n\nclass _LoadingIndicator extends StatelessWidget {\n  const _LoadingIndicator();\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox(\n      width: 20.w,\n      height: 20.h,\n      child: CircularProgressIndicator(strokeWidth: 2.w),\n    );\n  }\n}\n"
  },
  {
    "name": "card",
    "version": "0.0.1",
    "content": "//v0.0.1\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nclass CardVariant extends Equatable {\n  final CardTitle title;\n\n  final CardSubtitle? subtitle;\n\n  final CardContent content;\n\n  final CardFooter footer;\n\n  const CardVariant({\n    required this.title,\n    this.subtitle,\n    required this.content,\n    required this.footer,\n  });\n\n  @override\n  List<Object?> get props => [title, content, footer, subtitle];\n}\n\nclass CardDecoration extends Equatable {\n  final EdgeInsetsGeometry? padding;\n  final Border? border;\n  final BorderRadiusGeometry borderRadius;\n  final Color? color;\n  final List<BoxShadow>? boxShadow;\n  final CrossAxisAlignment childrenCrossAxisAlignment;\n\n  const CardDecoration({\n    this.padding,\n    this.border,\n    this.boxShadow,\n    this.borderRadius = const BorderRadius.all(Radius.circular(8)),\n    this.color,\n    this.childrenCrossAxisAlignment = CrossAxisAlignment.start,\n  });\n\n  @override\n  List<Object?> get props => [padding, border, borderRadius, color];\n}\n\nclass CardTitle extends Equatable {\n  final String title;\n\n  /// If [style] is null, it will use the default style\n  final TextStyle? style;\n\n  const CardTitle({\n    required this.title,\n    this.style,\n  });\n\n  @override\n  List<Object?> get props => [title, style];\n}\n\nclass CardSubtitle extends Equatable {\n  final String subtitle;\n\n  /// If [style] is null, it will use the default style\n  final TextStyle? style;\n\n  const CardSubtitle({\n    required this.subtitle,\n    this.style,\n  });\n\n  @override\n  List<Object?> get props => [subtitle, style];\n}\n\nclass CardContent extends Equatable {\n  final Widget content;\n\n  const CardContent({\n    required this.content,\n  });\n\n  @override\n  List<Object?> get props => [content];\n}\n\nclass CardFooter extends Equatable {\n  final List<Widget> footer;\n\n  final MainAxisAlignment mainAxisAlignment;\n\n  final Axis direction;\n\n  const CardFooter({\n    required this.footer,\n    this.mainAxisAlignment = MainAxisAlignment.spaceBetween,\n    this.direction = Axis.horizontal,\n  });\n\n  @override\n  List<Object?> get props => [footer, mainAxisAlignment, direction];\n}\n\nclass CardCustom extends Equatable {\n  final Widget widget;\n\n  const CardCustom({\n    required this.widget,\n  });\n\n  @override\n  List<Object?> get props => [widget];\n}\n\nclass DefaultCard extends StatelessWidget {\n  final CardVariant? variant;\n  final CardCustom? custom;\n  final CardDecoration decoration;\n\n  const DefaultCard({\n    super.key,\n    this.variant,\n    this.custom,\n    this.decoration = const CardDecoration(),\n  })\n  //Assert 1 of them is not null\n  : assert(variant != null || custom != null,\n            'DefaultCard: variant and custom cannot be null at the same time');\n\n  @override\n  Widget build(BuildContext context) {\n    return ThemeProvider(\n      builder: (context, vm) {\n        return getChild(vm);\n      },\n    );\n  }\n\n  Widget getChild(ThemeVm vm) {\n    return _getCard(vm.theme);\n  }\n\n  Widget _getCard(ThemeData theme) {\n    final EdgeInsets defaultPadding = const EdgeInsets.all(24).w;\n    final List<BoxShadow> cardShadow = [\n      BoxShadow(\n        offset: const Offset(0, 2).w,\n        blurRadius: 4.r,\n        spreadRadius: 0,\n        color: Colors.black.withOpacity(0.08),\n      ),\n      BoxShadow(\n        offset: const Offset(0, 3).w,\n        blurRadius: 10.r,\n        spreadRadius: 0,\n        color: Colors.black.withOpacity(0.1),\n      )\n    ];\n\n    final border = Border.all(\n            color: theme.colorScheme.onSurface.withOpacity(0.1),\n            strokeAlign: BorderSide.strokeAlignInside)\n        .w;\n\n    final color = decoration.color ?? theme.colorScheme.surface;\n\n    return DecoratedBox(\n        decoration: BoxDecoration(\n          color: color,\n          borderRadius: decoration.borderRadius,\n          boxShadow: decoration.boxShadow ?? cardShadow,\n          border: decoration.border ?? border,\n        ),\n        child: custom == null\n            ? Padding(\n                padding: decoration.padding?.w ?? defaultPadding,\n                child: Column(\n                  mainAxisSize: MainAxisSize.min,\n                  crossAxisAlignment: decoration.childrenCrossAxisAlignment,\n                  children: [\n                    _getTitle(theme),\n                    if (variant!.subtitle != null) _getSubtitle(theme),\n                    _getContent(theme),\n                    _getFooter(theme),\n                  ],\n                ),\n              )\n            : Padding(\n                padding: decoration.padding ?? defaultPadding,\n                child: custom!.widget,\n              ));\n  }\n\n  Widget _getTitle(ThemeData theme) {\n    final title = variant!.title;\n    return Text(\n      title.title,\n      style: (title.style ??\n              theme.textTheme.headlineSmall!\n                  .copyWith(fontWeight: FontWeight.bold))\n          .sp,\n    );\n  }\n\n  Widget _getSubtitle(ThemeData theme) {\n    final subtitle = variant!.subtitle!;\n\n    Widget widget = Text(\n      subtitle.subtitle,\n      style: (subtitle.style ??\n              theme.textTheme.labelLarge!.copyWith(\n                  fontWeight: FontWeight.normal,\n                  color: theme.colorScheme.onSurface.withOpacity(0.6)))\n          .sp,\n    );\n\n    return Padding(\n      padding: EdgeInsets.only(top: 12.h),\n      child: widget,\n    );\n  }\n\n  Widget _getContent(ThemeData theme) {\n    final content = variant!.content;\n\n    Widget widget = content.content;\n\n    return Padding(\n      padding: EdgeInsets.only(top: 22.h),\n      child: widget,\n    );\n  }\n\n  Widget _getFooter(ThemeData theme) {\n    final footer = variant!.footer;\n\n    Widget widget = Row(\n      mainAxisAlignment: footer.mainAxisAlignment,\n      children: footer.footer.length == 1\n          ? [Expanded(child: footer.footer.first)]\n          : footer.footer,\n    );\n\n    return Padding(\n      padding: EdgeInsets.only(top: 22.h),\n      child: widget,\n    );\n  }\n}\n"
  },
  {
    "name": "disabled",
    "version": "0.0.1",
    "content": "//v0.0.1\n\nimport 'package:flutter/material.dart';\n\nclass DisabledVm {\n  final bool disabled;\n  final double opacity;\n  final Widget child;\n  final bool showForbiddenCursor;\n\n  const DisabledVm({\n    required this.disabled,\n    this.opacity = .5,\n    required this.child,\n    this.showForbiddenCursor = true,\n  });\n}\n\nclass DefaultDisabled extends StatelessWidget {\n  final DisabledVm vm;\n  const DefaultDisabled({super.key, required this.vm});\n\n  @override\n  Widget build(BuildContext context) {\n    Widget view = AbsorbPointer(\n      absorbing: vm.disabled,\n      child: vm.child,\n    );\n\n    if (vm.showForbiddenCursor && vm.disabled) {\n      view = MouseRegion(cursor: SystemMouseCursors.forbidden, child: view);\n    }\n\n    return Opacity(opacity: vm.disabled ? vm.opacity : 1, child: view);\n  }\n}\n"
  },
  {
    "name": "input",
    "version": "0.0.1",
    "dependencies": [
      "form",
      "with_label",
      "save_button"
    ],
    "content": "//v0.0.1\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:fcnui_base/fcnui_base.dart';\n\nimport 'theme.dart';\nimport 'form.dart';\nimport 'disabled.dart';\n\nclass InputModel extends IFormModel {\n  final String? initialValue;\n  final ValueChanged<String?>? onChanged;\n  final int? maxLines;\n  final List<FormFieldValidator<String>> validators;\n  final List<TextInputFormatter> inputFormatters;\n  final bool enabled;\n  final bool readOnly;\n  final String? hintText;\n  final String? helperText;\n  final ValueTransformer<String?>? valueTransformer;\n  final TextEditingController? controller;\n  final FocusNode? focusNode;\n\n  const InputModel({\n    required super.name,\n    this.initialValue,\n    this.focusNode,\n    this.controller,\n    this.onChanged,\n    this.valueTransformer,\n    this.helperText,\n    this.enabled = true,\n    this.readOnly = false,\n    this.maxLines,\n    this.hintText,\n    this.validators = const [],\n    this.inputFormatters = const [],\n  });\n\n  @override\n  List<Object?> get props => [\n        name,\n        initialValue,\n        onChanged,\n        valueTransformer,\n        helperText,\n        enabled,\n        readOnly,\n        maxLines,\n        hintText,\n        validators,\n        inputFormatters,\n        controller,\n        focusNode,\n      ];\n}\n\nclass DefaultInput extends StatelessWidget {\n  final InputModel vm;\n\n  const DefaultInput({super.key, required this.vm});\n\n  @override\n  Widget build(BuildContext context) {\n    return ThemeProvider(builder: (context, vm) {\n      return _getChild(vm);\n    });\n  }\n\n  Widget _getChild(ThemeVm themeVm) {\n    final theme = themeVm.theme;\n    return DefaultDisabled(\n        vm: DisabledVm(\n      disabled: !vm.enabled,\n      child: Theme(\n        data: theme.copyWith(\n          inputDecorationTheme: InputDecorationTheme(\n            hoverColor: Colors.transparent,\n            //Border when tapped and focused\n            focusedBorder: OutlineInputBorder(\n                borderRadius:\n                    BorderRadius.circular(FcnuiDefaultSizes.borderRadius).r,\n                borderSide: BorderSide(\n                        color: theme.colorScheme.primary,\n                        width: FcnuiDefaultSizes.selectedBorderWidth,\n                        strokeAlign: BorderSide.strokeAlignOutside)\n                    .w),\n            //Idle state border\n            enabledBorder: OutlineInputBorder(\n              borderRadius:\n                  BorderRadius.circular(FcnuiDefaultSizes.borderRadius).r,\n              borderSide: BorderSide(\n                      color: theme.dividerColor,\n                      width: FcnuiDefaultSizes.borderWidth,\n                      strokeAlign: BorderSide.strokeAlignInside)\n                  .w,\n            ),\n            errorBorder: OutlineInputBorder(\n              borderRadius:\n                  BorderRadius.circular(FcnuiDefaultSizes.borderRadius).r,\n              borderSide: const BorderSide(\n                      color: Colors.red,\n                      width: FcnuiDefaultSizes.borderWidth,\n                      strokeAlign: BorderSide.strokeAlignInside)\n                  .w,\n            ),\n            disabledBorder: OutlineInputBorder(\n              borderRadius:\n                  BorderRadius.circular(FcnuiDefaultSizes.borderRadius).r,\n              borderSide: BorderSide(\n                      width: FcnuiDefaultSizes.borderWidth,\n                      color: theme.dividerColor.withOpacity(0.6),\n                      strokeAlign: BorderSide.strokeAlignInside)\n                  .w,\n            ),\n            focusedErrorBorder: OutlineInputBorder(\n              borderRadius:\n                  BorderRadius.circular(FcnuiDefaultSizes.borderRadius).r,\n              borderSide: const BorderSide(\n                      color: Colors.red,\n                      width: FcnuiDefaultSizes.selectedBorderWidth,\n                      strokeAlign: BorderSide.strokeAlignOutside)\n                  .w,\n            ),\n            errorStyle:\n                theme.textTheme.bodyMedium!.copyWith(color: Colors.red).sp,\n            helperStyle: theme.textTheme.bodyMedium!\n                .copyWith(color: theme.colorScheme.onSurface.withOpacity(0.6))\n                .sp,\n            contentPadding:\n                const EdgeInsets.symmetric(horizontal: 12, vertical: 8).w,\n            floatingLabelBehavior: FloatingLabelBehavior.never,\n            filled: true,\n            fillColor: theme.colorScheme.surface,\n            hintStyle: theme.textTheme.bodyMedium!\n                .copyWith(color: theme.colorScheme.onSurface.withOpacity(0.4))\n                .sp,\n          ),\n        ),\n        child: FormBuilderTextField(\n          focusNode: vm.focusNode,\n          controller: vm.controller,\n          style: theme.textTheme.bodyLarge!\n              .copyWith(\n                  color: theme.colorScheme.onSurface,\n                  fontWeight: FontWeight.normal)\n              .sp,\n          name: vm.name,\n          initialValue: vm.initialValue,\n          onChanged: vm.onChanged,\n          maxLines: vm.maxLines,\n          validator: FormBuilderValidators.compose(vm.validators),\n          inputFormatters: vm.inputFormatters,\n          enabled: vm.enabled,\n          valueTransformer: vm.valueTransformer,\n          readOnly: vm.readOnly,\n          decoration: InputDecoration(\n            helperText: vm.helperText,\n            hintText: vm.hintText,\n          ),\n        ),\n      ),\n    ));\n  }\n}\n"
  },
  {
    "name": "form",
    "version": "0.0.1",
    "content": "//v0.0.1\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nabstract class IFormModel extends Equatable {\n  ///This will form the key in the form value Map\n  final String name;\n\n  const IFormModel({\n    required this.name,\n  });\n}\n\nclass FormModel {\n  /// Used for [FormBuilder] to control form\n  final GlobalKey<FormBuilderState> formKey = GlobalKey<FormBuilderState>();\n\n  /// Used for [SaveButton] to enable/disable button\n  final ValueNotifier<bool> isValidFormNotifier = ValueNotifier(false);\n\n  /// Returns true if form is valid\n  bool get isValid => formKey.currentState?.isValid ?? false;\n\n  /// Callback for onChanged event\n  ///\n  /// Triggered when any field in form is changed\n  void Function()? onChanged;\n\n  /// Returns single value from form\n  dynamic getValue(String name) => formKey.currentState?.fields[name]?.value;\n\n  /// Returns all values from form\n  Map<String, dynamic> getValues() => formKey.currentState?.value ?? {};\n\n  /// Set single value to form\n  void patchValue(Map<String, dynamic> value, {bool isSave = true}) {\n    formKey.currentState?.patchValue(value);\n    if (isSave) save();\n  }\n\n  /// Set all values to form\n  void save() => formKey.currentState?.save();\n\n  /// Reset form to initial state\n  void reset() => formKey.currentState?.reset();\n\n  /// Validate form\n  void validate(\n          {bool focusOnInvalid = true,\n          bool autoScrollWhenFocusOnInvalid = false}) =>\n      formKey.currentState?.validate(\n          autoScrollWhenFocusOnInvalid: autoScrollWhenFocusOnInvalid,\n          focusOnInvalid: focusOnInvalid);\n\n  /// Save and validate form\n  void saveAndValidate(\n          {bool focusOnInvalid = true,\n          bool autoScrollWhenFocusOnInvalid = false}) =>\n      formKey.currentState?.saveAndValidate(\n          autoScrollWhenFocusOnInvalid: autoScrollWhenFocusOnInvalid,\n          focusOnInvalid: focusOnInvalid);\n\n  /// Invalidate field\n  ///\n  /// Show error message on field if it's invalid\n  void invalidateField(String name, String message) =>\n      formKey.currentState?.fields[name]\n          ?.invalidate(message, shouldFocus: false);\n}\n\nclass DefaultForm extends StatelessWidget {\n  final FormModel vm;\n  final Widget child;\n  final bool clearValueOnUnregister;\n\n  /// If true, the form will save and validate on every change\n  ///\n  /// Used to auto validate on form change\n  ///\n  /// If using [SaveButton] trigger [autoValidate] field true.\n  final bool saveAndValidateOnChange;\n  const DefaultForm(\n      {super.key,\n      required this.vm,\n      required this.child,\n      this.saveAndValidateOnChange = false,\n      this.clearValueOnUnregister = false});\n\n  @override\n  Widget build(BuildContext context) {\n    return FormBuilder(\n      clearValueOnUnregister: clearValueOnUnregister,\n      key: vm.formKey,\n      onChanged: () {\n        if (saveAndValidateOnChange) {\n          vm.formKey.currentState?.save();\n        }\n        vm.isValidFormNotifier.value = vm.isValid;\n        vm.onChanged?.call();\n      },\n      child: child,\n    );\n  }\n}\n"
  },
  {
    "name": "label",
    "version": "0.0.1",
    "dependencies": [
      "disabled"
    ],
    "content": "//v0.0.1\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\nimport 'disabled.dart';\n\nclass LabelModel extends Equatable {\n  final String text;\n  final bool isRequired;\n  final bool enabled;\n  const LabelModel({\n    required this.text,\n    this.enabled = true,\n    this.isRequired = false,\n  });\n\n  @override\n  List<Object?> get props => [\n        text,\n        isRequired,\n        enabled,\n      ];\n}\n\nclass Label extends StatelessWidget {\n  final LabelModel vm;\n  const Label({super.key, required this.vm});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultDisabled(\n        vm: DisabledVm(\n      disabled: !vm.enabled,\n      child: RichText(\n          text: TextSpan(children: [\n        TextSpan(\n            text: vm.text,\n            style: Theme.of(context).textTheme.titleSmall!.copyWith(\n                  fontWeight: FontWeight.normal,\n                  color: vm.enabled\n                      ? null\n                      : Theme.of(context)\n                          .colorScheme\n                          .onSurface\n                          .withOpacity(0.4),\n                )),\n        if (vm.isRequired)\n          TextSpan(\n              text: \"\\t*\",\n              style: Theme.of(context)\n                  .textTheme\n                  .titleMedium!\n                  .copyWith(color: Colors.red))\n      ])),\n    ));\n  }\n}\n"
  },
  {
    "name": "with_label",
    "version": "0.0.1",
    "dependencies": [
      "label"
    ],
    "content": "//v0.0.1\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\nimport 'label.dart';\n\nexport 'label.dart';\n\nclass WithLabel extends StatelessWidget {\n  final LabelModel labelVm;\n  final Widget child;\n  const WithLabel({super.key, required this.labelVm, required this.child});\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      mainAxisSize: MainAxisSize.min,\n      children: [\n        Label(vm: labelVm),\n        child,\n      ],\n    ).spaced(4);\n  }\n}\n"
  },
  {
    "name": "save_button",
    "version": "0.0.1",
    "dependencies": [
      "button",
      "form"
    ],
    "content": "//v0.0.1\n\nimport 'package:flutter/material.dart';\nimport 'form.dart';\nimport 'button.dart';\n\nclass SaveButton extends StatelessWidget {\n  final FormModel vm;\n  final ValueChanged<Map<String, dynamic>>? onSave;\n  final String text;\n  final bool autoValidate;\n  const SaveButton(\n      {super.key,\n      required this.vm,\n      required this.onSave,\n      this.text = \"Save\",\n      this.autoValidate = false});\n\n  @override\n  Widget build(BuildContext context) {\n    if (autoValidate) {\n      return ValueListenableBuilder<bool>(\n          valueListenable: vm.isValidFormNotifier,\n          builder: (context, value, child) {\n            return DefaultButton(\n              variant: PrimaryButtonVariant(\n                text: text,\n                onPressed: value\n                    ? () {\n                        vm.formKey.currentState?.saveAndValidate();\n                        onSave?.call(vm.formKey.currentState?.value\n                            as Map<String, dynamic>);\n                      }\n                    : null,\n              ),\n            );\n          });\n    } else {\n      return DefaultButton(\n        variant: PrimaryButtonVariant(\n            text: text,\n            onPressed: onSave == null\n                ? null\n                : () {\n                    vm.formKey.currentState?.saveAndValidate();\n                    onSave!(\n                        vm.formKey.currentState?.value as Map<String, dynamic>);\n                  }),\n      );\n    }\n  }\n}\n"
  },
  {
    "name": "dp_item",
    "version": "0.0.1",
    "content": "//v0.0.1\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nclass DpItem extends Equatable {\n  final String id;\n  final String title;\n  final String? subtitle;\n  final IconData? icon;\n\n  const DpItem(\n      {required this.id, required this.title, this.subtitle, this.icon});\n\n  @override\n  List<Object?> get props => [id, title, subtitle, icon];\n\n  //copyWith\n  DpItem copyWith({\n    String? id,\n    String? title,\n    String? subtitle,\n    IconData? icon,\n  }) {\n    return DpItem(\n      id: id ?? this.id,\n      title: title ?? this.title,\n      subtitle: subtitle ?? this.subtitle,\n      icon: icon ?? this.icon,\n    );\n  }\n}\n"
  },
  {
    "name": "checkbox",
    "version": "0.0.1",
    "dependencies": [
      "disabled",
      "form",
      "dp_item"
    ],
    "content": "//v0.0.1\n\nimport 'dart:developer';\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\nimport 'disabled.dart';\nimport 'dp_item.dart';\nimport 'form.dart';\n\nclass CheckboxModel extends IFormModel {\n  final List<DpItem> items;\n  final ValueChanged<List<String>?>? onChanged;\n  final List<String>? initialValues;\n  final List<String> disabled;\n  final bool enabled;\n  final String? Function(List<String>?)? validator;\n  final OptionsOrientation? orientation;\n  final AutovalidateMode autovalidateMode;\n  final Axis? wrapDirection;\n  final String? helperText;\n  final String? title;\n  final String? subtitle;\n\n  const CheckboxModel({\n    required super.name,\n    required this.items,\n    this.onChanged,\n    this.wrapDirection,\n    this.orientation,\n    this.autovalidateMode = AutovalidateMode.disabled,\n    this.initialValues,\n    this.helperText,\n    this.disabled = const [],\n    this.enabled = true,\n    this.validator,\n    this.subtitle,\n    this.title,\n  });\n\n  @override\n  List<Object?> get props => [\n        name,\n        items,\n        onChanged,\n        orientation,\n        initialValues,\n        disabled,\n        enabled,\n        validator,\n        autovalidateMode,\n        wrapDirection,\n        helperText,\n        title,\n        subtitle,\n      ];\n}\n\nclass DefaultCheckbox extends StatelessWidget {\n  final CheckboxModel vm;\n  const DefaultCheckbox({super.key, required this.vm});\n\n  @override\n  Widget build(BuildContext context) {\n    return ThemeProvider(builder: (context, themeVm) {\n      final theme = themeVm.theme;\n      return _getChild(theme);\n    });\n  }\n\n  Widget _getChild(ThemeData theme) {\n    return DefaultDisabled(\n        vm: DisabledVm(\n      disabled: !vm.enabled,\n      child: Theme(\n        data: theme.copyWith(checkboxTheme: _getCheckboxTheme(theme)),\n        child: FormBuilderField<List<String>>(\n          name: vm.name,\n          enabled: vm.enabled,\n          validator: vm.validator,\n          onChanged: vm.onChanged,\n          initialValue: vm.initialValues,\n          autovalidateMode: vm.autovalidateMode,\n          builder: (field) {\n            return Column(\n              mainAxisSize: MainAxisSize.min,\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                if (vm.title != null)\n                  Text(vm.title!,\n                      style: theme.textTheme.titleMedium!.copyWith(\n                        color: field.errorText == null ? null : Colors.red,\n                      )),\n                if (vm.subtitle != null)\n                  Text(vm.subtitle!,\n                      style: theme.textTheme.bodySmall!.copyWith(\n                          color: theme.colorScheme.onSurface.withOpacity(0.6))),\n                if (vm.title != null || vm.subtitle != null)\n                  const SizedBox(height: 4),\n                GroupCheckbox(field: field, vm: vm),\n                if (vm.helperText != null)\n                  Text(vm.helperText!, style: theme.textTheme.bodyMedium),\n                if (field.errorText != null)\n                  Text(\n                    field.errorText!,\n                    style:\n                        theme.textTheme.bodySmall?.copyWith(color: Colors.red),\n                  ),\n              ],\n            ).spaced(4);\n          },\n        ),\n      ),\n    ));\n  }\n\n  CheckboxThemeData _getCheckboxTheme(ThemeData theme) {\n    return theme.checkboxTheme.copyWith(\n        side: BorderSide(color: theme.colorScheme.onSurface, width: 1).w,\n        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4).r),\n        overlayColor: const MaterialStatePropertyAll(Colors.transparent),\n        splashRadius: 0);\n  }\n}\n\nclass GroupCheckbox extends StatelessWidget {\n  final FormFieldState<List<String>> field;\n  final CheckboxModel vm;\n  const GroupCheckbox({super.key, required this.field, required this.vm});\n\n  @override\n  Widget build(BuildContext context) {\n    if (vm.orientation == OptionsOrientation.horizontal) {\n      return Row(\n        mainAxisSize: MainAxisSize.min,\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          for (final item in vm.items)\n            CustomCheckbox(\n              field: field,\n              item: item,\n              vm: vm,\n            ),\n        ],\n      );\n    } else if (vm.orientation == OptionsOrientation.vertical) {\n      return Column(\n        mainAxisSize: MainAxisSize.min,\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          for (final item in vm.items)\n            CustomCheckbox(\n              field: field,\n              item: item,\n              vm: vm,\n            ),\n        ],\n      );\n    }\n    return Wrap(\n      spacing: 10.0,\n      runSpacing: 10.0,\n      direction: vm.wrapDirection ?? Axis.horizontal,\n      children: [\n        for (final item in vm.items)\n          CustomCheckbox(\n            field: field,\n            item: item,\n            vm: vm,\n          ),\n      ],\n    );\n  }\n}\n\nclass CustomCheckbox extends StatelessWidget {\n  final FormFieldState<List<String>> field;\n  final DpItem item;\n  final CheckboxModel vm;\n\n  const CustomCheckbox(\n      {super.key, required this.field, required this.vm, required this.item});\n\n  @override\n  Widget build(BuildContext context) {\n    final bool isDisabled = vm.disabled.contains(item.id);\n    final textTheme = Theme.of(context).textTheme;\n    final colorScheme = Theme.of(context).colorScheme;\n    final bool isValid = field.errorText == null;\n    return DefaultDisabled(\n      vm: DisabledVm(\n          disabled: isDisabled,\n          child: GestureDetector(\n            onTap: () {\n              onCheckboxChanged(!(field.value?.contains(item.id) ?? false));\n            },\n            child: Row(\n              mainAxisSize: MainAxisSize.min,\n              crossAxisAlignment: item.subtitle != null\n                  ? CrossAxisAlignment.start\n                  : CrossAxisAlignment.center,\n              children: [\n                //Checkbox\n                Checkbox(\n                    value: field.value?.contains(item.id) ??\n                        vm.initialValues?.contains(item.id) ??\n                        false,\n                    onChanged: onCheckboxChanged),\n\n                Column(\n                  mainAxisSize: MainAxisSize.min,\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: [\n                    //Title\n                    Text(\n                      item.title,\n                      style: TextStyle(\n                        color:\n                            isValid ? null : (isDisabled ? null : Colors.red),\n                      ),\n                    ),\n\n                    //Subtitle, if any\n                    if (item.subtitle != null)\n                      Text(item.subtitle!,\n                          style: textTheme.bodySmall?.copyWith(\n                              color: colorScheme.onSurface.withOpacity(0.6))),\n                  ],\n                ).spaced(2),\n              ],\n            ).spaced(4),\n          )),\n    );\n  }\n\n  void onCheckboxChanged(bool? value) {\n    try {\n      if (value == true) {\n        field.didChange([...(field.value ?? []), item.id]);\n      } else {\n        field.didChange(field.value?.where((e) => e != item.id).toList() ?? []);\n      }\n      vm.onChanged?.call(field.value);\n    } catch (e, st) {\n      log(e.toString());\n      log(st.toString());\n    }\n  }\n}\n"
  },
  {
    "name": "dropdown",
    "version": "0.0.1",
    "dependencies": [
      "input",
      "dp_item"
    ],
    "content": "import 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\nimport 'form.dart';\nimport 'input.dart';\nimport 'disabled.dart';\nimport 'dp_item.dart';\n\nclass DropdownItem extends Equatable {\n  final String? groupTitle;\n  final IconData? groupIcon;\n  final List<DpItem> items;\n\n  const DropdownItem({\n    this.groupTitle,\n    required this.items,\n    this.groupIcon,\n  });\n\n  @override\n  List<Object?> get props => [groupTitle, items, groupIcon];\n\n  //copyWith\n  DropdownItem copyWith({\n    String? groupTitle,\n    IconData? groupIcon,\n    List<DpItem>? items,\n  }) {\n    return DropdownItem(\n      groupTitle: groupTitle ?? this.groupTitle,\n      groupIcon: groupIcon ?? this.groupIcon,\n      items: items ?? this.items,\n    );\n  }\n}\n\nclass DropdownVariant extends IFormModel {\n  final DpForm form;\n  final DpDecoration decoration;\n  final List<String> disabledItems;\n\n  const DropdownVariant({\n    required super.name,\n    this.disabledItems = const [],\n    required this.form,\n    this.decoration = const DpDecoration(),\n  });\n\n  @override\n  List<Object?> get props => [name, form, decoration, disabledItems];\n}\n\nclass DpForm extends Equatable {\n  final List<DropdownItem> items;\n\n  ///If null, then disabled\n  final void Function(String?)? onChanged;\n\n  final String? initialValue;\n  final String? Function(String?)? validator;\n  final AutovalidateMode? autovalidateMode;\n\n  DpForm({\n    required this.items,\n    this.onChanged,\n    this.initialValue,\n    this.validator,\n    this.autovalidateMode,\n  })  :\n        //assert if items has same id\n        assert(\n            items\n                    .expand((element) => element.items)\n                    .map((e) => e.id)\n                    .toSet()\n                    .length ==\n                items\n                    .expand((element) => element.items)\n                    .map((e) => e.id)\n                    .length,\n            \"Items id must be unique\"),\n        //assert if items has at least one item\n        assert(items.isNotEmpty, \"Items cannot be empty\");\n\n  @override\n  List<Object?> get props =>\n      [items, onChanged, initialValue, validator, autovalidateMode];\n}\n\nclass DpDecoration extends Equatable {\n  final String? hintText;\n  final IconData? icon;\n  final Color? selectedColor;\n  final Color? hoverColor;\n  final String? searchHintText;\n  final Color? backgroundColor;\n  final Color? foregroundColor;\n  final String? helperText;\n  final bool hasSearchBox;\n  final bool hasBorder;\n  final Widget? customWidget;\n  final double? defaultMenuItemWidth;\n\n  const DpDecoration({\n    this.hintText,\n    this.icon,\n    this.backgroundColor,\n    this.selectedColor,\n    this.hoverColor,\n    this.searchHintText,\n    this.foregroundColor,\n    this.helperText,\n    this.hasSearchBox = false,\n    this.customWidget,\n    this.hasBorder = true,\n    this.defaultMenuItemWidth,\n  });\n\n  @override\n  List<Object?> get props => [\n        hintText,\n        icon,\n        selectedColor,\n        hoverColor,\n        searchHintText,\n        backgroundColor,\n        foregroundColor,\n        helperText,\n        hasSearchBox,\n        customWidget,\n        hasBorder,\n        defaultMenuItemWidth,\n      ];\n}\n\nclass DefaultDropdown extends StatelessWidget {\n  final DropdownVariant variant;\n\n  const DefaultDropdown({super.key, required this.variant});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultDisabled(\n      vm: DisabledVm(\n          disabled: variant.form.onChanged == null,\n          child: FormBuilderField<String>(\n            name: variant.name,\n            validator: variant.form.validator,\n            initialValue: variant.form.initialValue,\n            onChanged: variant.form.onChanged,\n            autovalidateMode: variant.form.autovalidateMode,\n            enabled: variant.form.onChanged != null,\n            builder: (FormFieldState<String> state) {\n              return _DropdownSelect(state: state, variant: variant);\n            },\n          )),\n    );\n  }\n}\n\nclass _DropdownSelect extends StatefulWidget {\n  final FormFieldState<String>? state;\n  final DropdownVariant variant;\n\n  const _DropdownSelect({this.state, required this.variant});\n\n  @override\n  State<_DropdownSelect> createState() => __DropdownSelectState();\n}\n\nclass __DropdownSelectState extends State<_DropdownSelect> {\n  final TextEditingController searchController = TextEditingController();\n\n  DropdownVariant get variant => widget.variant;\n\n  FormFieldState<String>? get state => widget.state;\n\n  String? get errorText => state?.errorText;\n\n  DpItem? get selectedItem => variant.form.items\n      .expand((element) => element.items)\n      .firstWhereOrNull((element) => element.id == state?.value);\n\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addPostFrameCallback((timeStamp) {\n      if (variant.form.initialValue != null) {\n        state?.didChange(variant.form.initialValue);\n      }\n    });\n  }\n\n  @override\n  void dispose() {\n    searchController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final bool isError = state?.hasError == true;\n    final String? errorText = state?.errorText;\n    return ThemeProvider(builder: (context, themeVm) {\n      final ThemeData theme = themeVm.theme;\n      return Theme(\n        data: theme,\n        child: DropdownButtonFormField2<DpItem>(\n          items: _getItems(themeVm.theme),\n          value: selectedItem,\n          hint: variant.decoration.hintText != null\n              ? Text(\n                  variant.decoration.hintText!,\n                  overflow: TextOverflow.ellipsis,\n                  style: theme.textTheme.bodyMedium!.copyWith(\n                      fontWeight: FontWeight.normal,\n                      color: variant.decoration.foregroundColor ??\n                          theme.colorScheme.onSurface.withOpacity(0.4)),\n                )\n              : null,\n          dropdownSearchData: variant.decoration.hasSearchBox\n              ? DropdownSearchData(\n                  searchController: searchController,\n                  searchInnerWidget: Padding(\n                    padding: const EdgeInsets.only(left: 8, right: 8, top: 8).w,\n                    child: DefaultInput(\n                        vm: InputModel(\n                      controller: searchController,\n                      name: \"${variant.name}Search\",\n                      hintText: variant.decoration.searchHintText ?? \"Search\",\n                    )),\n                  ),\n                  searchMatchFn: (item, searchValue) {\n                    bool found = false;\n                    if (item.value?.title\n                            .toLowerCase()\n                            .contains(searchValue.toLowerCase()) ??\n                        false) {\n                      found = true;\n                    } else {\n                      if (item.value?.subtitle\n                              ?.toLowerCase()\n                              .contains(searchValue.toLowerCase()) ??\n                          false) {\n                        found = true;\n                      }\n                    }\n                    return found;\n                  },\n                  searchInnerWidgetHeight: 36.h,\n                )\n              : null,\n          decoration: InputDecoration(\n              filled: false,\n              errorText: isError ? errorText : null,\n              errorStyle:\n                  theme.textTheme.bodyMedium!.copyWith(color: Colors.red),\n              hoverColor: Colors.transparent,\n              helperText: variant.decoration.helperText,\n              helperStyle: theme.textTheme.bodySmall!.copyWith(\n                  color: theme.colorScheme.onSurface.withOpacity(0.4))),\n          onChanged: variant.form.onChanged == null\n              ? null\n              : (value) {\n                  state?.didChange(value?.id);\n                },\n          customButton: variant.decoration.customWidget,\n          dropdownStyleData: _getDropdownStyle(theme),\n          iconStyleData: _getIconStyle(theme),\n          menuItemStyleData: _getMenuItemStyle(theme),\n          selectedItemBuilder: (context) {\n            return _getItems(theme).map((e) {\n              return RichText(\n                overflow: TextOverflow.ellipsis,\n                text: TextSpan(children: [\n                  TextSpan(\n                      text: selectedItem?.title,\n                      style: theme.textTheme.bodyLarge!\n                          .copyWith(color: variant.decoration.foregroundColor)),\n                ]),\n              );\n            }).toList();\n          },\n          buttonStyleData: ButtonStyleData(\n            elevation: 0,\n            overlayColor: MaterialStateProperty.resolveWith((states) {\n              return Colors.transparent;\n            }),\n          ),\n        ),\n      );\n    });\n  }\n\n  IconStyleData _getIconStyle(ThemeData theme) {\n    return IconStyleData(\n      icon: Padding(\n        padding: const EdgeInsets.only(right: 16.0).w,\n        child: Icon(\n          variant.decoration.icon ?? Icons.unfold_more,\n          color: variant.decoration.foregroundColor ??\n              theme.colorScheme.onSurface.withOpacity(0.6),\n          size: 16.w,\n        ),\n      ),\n    );\n  }\n\n  DropdownStyleData _getDropdownStyle(ThemeData theme) {\n    final shadows = [\n      BoxShadow(\n        offset: const Offset(0, 2).w,\n        color: Colors.black.withOpacity(0.08),\n        blurRadius: 4.w,\n        spreadRadius: 0,\n      ),\n      BoxShadow(\n        offset: const Offset(0, 4).w,\n        color: Colors.black.withOpacity(0.1),\n        blurRadius: 10.w,\n        spreadRadius: 0,\n      ),\n    ];\n    return DropdownStyleData(\n      maxHeight: 300.h,\n      width: variant.decoration.defaultMenuItemWidth?.w,\n      padding: const EdgeInsets.all(8).w,\n      elevation: 0,\n      offset: const Offset(0, -4).w,\n      decoration: BoxDecoration(\n        boxShadow: shadows,\n        border: Border.all(\n          color: theme.dividerColor.withOpacity(0.6),\n          width: 1.w,\n        ),\n        borderRadius: BorderRadius.circular(4).r,\n      ),\n    );\n  }\n\n  MenuItemStyleData _getMenuItemStyle(ThemeData theme) {\n    return MenuItemStyleData(\n        overlayColor: MaterialStateProperty.resolveWith((states) {\n          if (states.contains(MaterialState.hovered)) {\n            return variant.decoration.hoverColor ??\n                variant.decoration.backgroundColor ??\n                theme.dividerColor.withOpacity(0.2);\n          }\n          return null;\n        }),\n        selectedMenuItemBuilder: (context, child) {\n          return DecoratedBox(\n            decoration: BoxDecoration(\n              color: variant.decoration.selectedColor ??\n                  variant.decoration.backgroundColor ??\n                  theme.dividerColor.withOpacity(0.4),\n              borderRadius: BorderRadius.circular(4).r,\n            ),\n            child: child,\n          );\n        },\n        padding: const EdgeInsets.all(0).w,\n        customHeights: _getCustomHeights());\n  }\n\n  List<double> _getCustomHeights() {\n    final List<double> customHeights = [];\n    //if has group title => 35\n    //if has subtitle => 50\n    //if has only title => 35\n    for (final groupItem in variant.form.items) {\n      if (groupItem.groupTitle != null) {\n        customHeights.add(35.h);\n      }\n      for (final item in groupItem.items) {\n        if (item.subtitle != null) {\n          customHeights.add(50.h);\n        } else {\n          customHeights.add(35.h);\n        }\n      }\n    }\n    return customHeights;\n  }\n\n  String? hoveringId;\n\n  List<DropdownMenuItem<DpItem>> _getItems(ThemeData theme) {\n    final List<DropdownMenuItem<DpItem>> items = [];\n\n    for (final groupItem in variant.form.items) {\n      if (groupItem.groupTitle != null) {\n        items.add(DropdownMenuItem<DpItem>(\n          value: DpItem(\n              id: \"title${groupItem.groupTitle}\", title: groupItem.groupTitle!),\n          enabled: false,\n          child: Container(\n            margin: const EdgeInsets.symmetric(horizontal: 8).w,\n            child: Row(\n              mainAxisSize: MainAxisSize.min,\n              children: [\n                if (groupItem.groupIcon != null)\n                  Icon(groupItem.groupIcon,\n                      color: theme.colorScheme.onSurface.withOpacity(0.6),\n                      size: 16.w),\n                Text(groupItem.groupTitle!, style: theme.textTheme.titleMedium),\n              ],\n            ).spaced(8),\n          ),\n        ));\n      }\n      for (final item in groupItem.items) {\n        items.add(DropdownMenuItem<DpItem>(\n          value: item,\n          enabled: !variant.disabledItems.contains(item.id),\n          child: DefaultDisabled(\n              vm: DisabledVm(\n            disabled: variant.disabledItems.contains(item.id),\n            child: Container(\n              width: double.infinity,\n              height: double.infinity,\n              padding: const EdgeInsets.symmetric(horizontal: 8).w,\n              alignment: Alignment.centerLeft,\n              child: Row(\n                mainAxisSize: MainAxisSize.min,\n                crossAxisAlignment: CrossAxisAlignment.center,\n                children: [\n                  if (item.icon != null)\n                    Row(\n                      mainAxisSize: MainAxisSize.min,\n                      children: [\n                        Icon(item.icon,\n                            color: theme.colorScheme.onSurface.withOpacity(0.6),\n                            size: 16.w),\n                        const SizedBox(width: 8).w,\n                      ],\n                    ),\n                  Expanded(\n                    child: Column(\n                      crossAxisAlignment: CrossAxisAlignment.start,\n                      mainAxisSize: MainAxisSize.min,\n                      children: [\n                        Text(item.title,\n                            maxLines: 1,\n                            overflow: TextOverflow.ellipsis,\n                            style: theme.textTheme.bodyMedium),\n                        if (item.subtitle != null)\n                          Text(item.subtitle!,\n                              maxLines: 1,\n                              overflow: TextOverflow.ellipsis,\n                              style: theme.textTheme.bodySmall!.copyWith(\n                                color: theme.colorScheme.onSurface\n                                    .withOpacity(0.6),\n                              )),\n                      ],\n                    ),\n                  ),\n                ],\n              ),\n            ),\n          )),\n        ));\n      }\n    }\n    return items;\n  }\n}\n"
  },
  {
    "name": "switch",
    "version": "0.0.1",
    "dependencies": [
      "form",
      "disabled"
    ],
    "content": "//v0.0.1\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nimport 'disabled.dart';\nimport 'form.dart';\n\nclass SwitchModel extends IFormModel {\n  final SwitchForm form;\n  final SwitchDecoration decoration;\n\n  const SwitchModel({\n    required super.name,\n    this.form = const SwitchForm(),\n    this.decoration = const SwitchDecoration(),\n  });\n\n  @override\n  List<Object?> get props => [\n        name,\n        form,\n        decoration,\n      ];\n}\n\nclass SwitchForm extends Equatable {\n  final ValueChanged<bool?>? onChanged;\n  final bool? initialValue;\n  final String? Function(bool?)? validator;\n  final AutovalidateMode? autovalidateMode;\n\n  const SwitchForm({\n    this.onChanged,\n    this.initialValue,\n    this.validator,\n    this.autovalidateMode,\n  });\n\n  @override\n  List<Object?> get props =>\n      [onChanged, initialValue, validator, autovalidateMode];\n}\n\nclass SwitchDecoration extends Equatable {\n  final String? title;\n  final String? subtitle;\n  final bool enabled;\n  final IconData? thumbActiveIcon;\n  final IconData? thumbInactiveIcon;\n  final Color thumbActiveColor;\n  final Color thumbInactiveColor;\n  final Color? trackActiveColor;\n  final Color? trackInactiveColor;\n  final double width;\n  final double height;\n\n  const SwitchDecoration({\n    this.title,\n    this.subtitle,\n    this.enabled = true,\n    this.thumbActiveIcon,\n    this.thumbInactiveIcon,\n    this.thumbActiveColor = Colors.white,\n    this.thumbInactiveColor = Colors.white,\n    this.trackActiveColor,\n    this.trackInactiveColor,\n    this.width = 45,\n    this.height = 24,\n  });\n\n  @override\n  List<Object?> get props => [\n        title,\n        subtitle,\n        enabled,\n        width,\n        height,\n        thumbActiveColor,\n        thumbInactiveColor,\n        trackActiveColor,\n        trackInactiveColor,\n        thumbActiveIcon,\n        thumbInactiveIcon,\n      ];\n}\n\nclass DefaultSwitch extends StatelessWidget {\n  final SwitchModel vm;\n\n  const DefaultSwitch({super.key, required this.vm});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultDisabled(\n      vm: DisabledVm(\n        disabled: !vm.decoration.enabled,\n        child: FormBuilderField<bool>(\n          name: vm.name,\n          validator: vm.form.validator,\n          enabled: vm.decoration.enabled,\n          initialValue: vm.form.initialValue,\n          onChanged: vm.form.onChanged,\n          autovalidateMode: vm.form.autovalidateMode,\n          builder: (field) {\n            return _Switch(field: field, vm: vm);\n          },\n        ),\n      ),\n    );\n  }\n}\n\nclass _Switch extends StatefulWidget {\n  final FormFieldState<bool> field;\n  final SwitchModel vm;\n\n  const _Switch({required this.field, required this.vm});\n\n  @override\n  State<_Switch> createState() => _SwitchState();\n}\n\nclass _SwitchState extends State<_Switch> {\n  FormFieldState<bool> get field => widget.field;\n\n  SwitchModel get vm => widget.vm;\n\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      field.didChange(vm.form.initialValue ?? false);\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final errorText = field.errorText;\n    final isError = errorText != null;\n    return ThemeProvider(builder: (context, themeVm) {\n      final theme = themeVm.theme;\n      return Theme(\n        data: theme.copyWith(\n          switchTheme: theme.switchTheme.copyWith(\n            trackOutlineWidth: MaterialStateProperty.all(0),\n            splashRadius: 17,\n          ),\n        ),\n        child: Column(\n          mainAxisSize: MainAxisSize.min,\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Row(\n              mainAxisSize: MainAxisSize.min,\n              children: [\n                SizedBox(\n                    width: vm.decoration.width,\n                    height: vm.decoration.height,\n                    child: FittedBox(\n                        fit: BoxFit.cover,\n                        child: Switch(\n                          value: field.value ?? false,\n                          onChanged: field.didChange,\n                          focusColor:\n                              theme.colorScheme.primary.withOpacity(0.12),\n                          thumbIcon:\n                              MaterialStateProperty.resolveWith((states) {\n                            //Handle states here. Ex: disabled, error, etc.\n                            //check if active\n                            if (field.value == true) {\n                              return Icon(vm.decoration.thumbActiveIcon);\n                            }\n                            //check if inactive\n                            return Icon(vm.decoration.thumbInactiveIcon);\n                          }),\n                          thumbColor:\n                              MaterialStateProperty.resolveWith((states) {\n                            //Handle states here. Ex: disabled, error, etc.\n                            //check if active\n                            if (field.value == true) {\n                              return vm.decoration.thumbActiveColor;\n                            }\n                            //check if inactive\n                            return vm.decoration.thumbInactiveColor;\n                          }),\n                          trackColor:\n                              MaterialStateProperty.resolveWith((states) {\n                            //Handle states here. Ex: disabled, error, etc.\n                            // check if active\n                            if (field.value == true) {\n                              return vm.decoration.trackActiveColor;\n                            }\n                            //check if inactive\n                            return vm.decoration.trackInactiveColor;\n                          }),\n                          trackOutlineColor:\n                              MaterialStateProperty.resolveWith((states) {\n                            return theme.colorScheme.onSurface\n                                .withOpacity(0.05);\n                          }),\n                        ))).w,\n                if (vm.decoration.title != null ||\n                    vm.decoration.subtitle != null)\n                  GestureDetector(\n                    onTap: () => field.didChange(field.value == null\n                        ? vm.form.initialValue\n                        : !field.value!),\n                    child: Column(\n                      mainAxisSize: MainAxisSize.min,\n                      crossAxisAlignment: CrossAxisAlignment.start,\n                      children: [\n                        if (vm.decoration.title != null)\n                          Text(vm.decoration.title!,\n                              style: theme.textTheme.titleSmall!.copyWith(\n                                  fontWeight: FontWeight.normal,\n                                  color: isError ? Colors.red : null)),\n                        if (vm.decoration.subtitle != null)\n                          Text(vm.decoration.subtitle!,\n                              style: theme.textTheme.bodySmall!.copyWith(\n                                  color: theme.colorScheme.onSurface\n                                      .withOpacity(0.6))),\n                      ],\n                    ),\n                  ),\n              ],\n            ).spaced(4),\n            if (isError)\n              Text(\n                errorText,\n                style: theme.textTheme.bodySmall!.copyWith(color: Colors.red),\n              ),\n          ],\n        ).spaced(4),\n      );\n    });\n  }\n}\n"
  },
  {
    "name": "radio",
    "version": "0.0.1",
    "dependencies": [
      "form",
      "disabled",
      "dp_item"
    ],
    "content": "//v0.0.1\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nimport 'disabled.dart';\nimport 'form.dart';\nimport 'dp_item.dart';\n\nclass RadioModel extends IFormModel {\n  const RadioModel(\n      {required super.name,\n      required this.form,\n      this.decoration = const RadioDecoration()});\n\n  final RadioForm form;\n  final RadioDecoration decoration;\n\n  @override\n  List<Object?> get props => [name, form, decoration];\n}\n\nclass RadioForm extends Equatable {\n  final List<DpItem> items;\n  final ValueChanged<String?>? onChanged;\n  final FormFieldValidator<String>? validator;\n  final String? initialValue;\n  final List<String> disabled;\n  final AutovalidateMode? autovalidateMode;\n\n  const RadioForm(\n      {required this.items,\n      this.onChanged,\n      this.validator,\n      this.initialValue,\n      this.autovalidateMode,\n      this.disabled = const []});\n\n  @override\n  List<Object?> get props =>\n      [items, onChanged, validator, initialValue, disabled, autovalidateMode];\n}\n\nclass RadioDecoration extends Equatable {\n  final String? title;\n  final ControlAffinity controlAffinity;\n  final OptionsOrientation direction;\n  final Widget? separatorWidget;\n  final Color? activeColor;\n  final Color? inactiveColor;\n\n  const RadioDecoration(\n      {this.title,\n      this.controlAffinity = ControlAffinity.leading,\n      this.direction = OptionsOrientation.vertical,\n      this.separatorWidget,\n      this.activeColor,\n      this.inactiveColor});\n\n  @override\n  List<Object?> get props =>\n      [title, controlAffinity, direction, separatorWidget];\n}\n\nclass DefaultRadio extends StatelessWidget {\n  final RadioModel vm;\n\n  const DefaultRadio({super.key, required this.vm});\n\n  RadioThemeData _getRadioTheme(ThemeData theme) {\n    return RadioThemeData(\n      splashRadius: 8,\n      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,\n      fillColor: MaterialStateProperty.resolveWith((states) {\n        //if selected\n        if (states.contains(MaterialState.selected)) {\n          return vm.decoration.activeColor;\n        }\n        if (states.contains(MaterialState.disabled)) {\n          return null;\n        }\n        return vm.decoration.inactiveColor;\n      }),\n      mouseCursor: MaterialStateProperty.resolveWith((states) {\n        //if disabled return not-allowed\n        if (states.contains(MaterialState.disabled)) {\n          return SystemMouseCursors.forbidden;\n        }\n        return null;\n      }),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultDisabled(\n      vm: DisabledVm(\n        disabled: vm.form.onChanged == null,\n        child: ThemeProvider(builder: (context, themeVm) {\n          final theme = themeVm.theme;\n          return Theme(\n            data: theme.copyWith(\n              inputDecorationTheme: const InputDecorationTheme(\n                  border: InputBorder.none,\n                  focusedBorder: InputBorder.none,\n                  enabledBorder: InputBorder.none,\n                  errorBorder: InputBorder.none,\n                  disabledBorder: InputBorder.none,\n                  focusedErrorBorder: InputBorder.none,\n                  contentPadding: EdgeInsets.zero,\n                  errorStyle: TextStyle(\n                    color: Colors.red,\n                  ),\n                  errorMaxLines: 2),\n              radioTheme: _getRadioTheme(theme),\n            ),\n            child: Column(\n              mainAxisSize: MainAxisSize.min,\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                if (vm.decoration.title != null)\n                  Text(vm.decoration.title!, style: theme.textTheme.titleSmall),\n                FormBuilderRadioGroup<String>(\n                    name: vm.name,\n                    onChanged: vm.form.onChanged,\n                    enabled: vm.form.onChanged != null,\n                    validator: vm.form.validator,\n                    initialValue: vm.form.initialValue,\n                    disabled: vm.form.disabled,\n                    controlAffinity: vm.decoration.controlAffinity,\n                    autovalidateMode: vm.form.autovalidateMode,\n                    separator: vm.decoration.separatorWidget,\n                    orientation: vm.decoration.direction,\n                    wrapDirection:\n                        vm.decoration.direction == OptionsOrientation.vertical\n                            ? Axis.vertical\n                            : Axis.horizontal,\n                    wrapRunSpacing: 12.w,\n                    wrapSpacing: 12.w,\n                    options: vm.form.items\n                        .map((e) => FormBuilderFieldOption(\n                            value: e.id,\n                            child: DefaultDisabled(\n                              vm: DisabledVm(\n                                disabled: vm.form.disabled.contains(e.id),\n                                child: Column(\n                                  mainAxisSize: MainAxisSize.min,\n                                  crossAxisAlignment: CrossAxisAlignment.start,\n                                  children: [\n                                    Text(e.title,\n                                        style: theme.textTheme.bodyMedium!),\n                                    if (e.subtitle != null)\n                                      Text(\n                                        e.subtitle!,\n                                        style: theme.textTheme.bodySmall!\n                                            .copyWith(\n                                                color: theme\n                                                    .colorScheme.onSurface\n                                                    .withOpacity(0.6)),\n                                      ),\n                                  ],\n                                ),\n                              ),\n                            )))\n                        .toList()),\n              ],\n            ).spaced(8),\n          );\n        }),\n      ),\n    );\n  }\n}\n"
  },
  {
    "name": "pagination",
    "version": "0.0.1",
    "dependencies": [
      "button",
      "theme"
    ],
    "content": "//v0.0.1\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nimport 'theme.dart';\nimport 'button.dart';\n\nclass DefaultPagination extends StatelessWidget {\n  final int totalPages;\n  final ValueChanged<int> onPageChanged;\n  final int currentPage;\n\n  /// The number of page buttons to show\n  ///\n  /// Default is 7\n  final int limit;\n\n  const DefaultPagination(\n      {super.key,\n      required this.totalPages,\n      this.limit = 7,\n      required this.onPageChanged,\n      required this.currentPage});\n\n  bool get isFirstPage => currentPage == 1;\n  bool get isLastPage => currentPage == totalPages;\n\n  @override\n  Widget build(BuildContext context) {\n    // If list of numbers are more than 8, then show 3 dots in the middle;\n    // If list of numbers are less than 8, then show all numbers;\n\n    return Container(\n      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8).w,\n      decoration: BoxDecoration(\n        color: FcnuiDefaultColor(context).borderColor,\n        borderRadius: BorderRadius.circular(FcnuiDefaultSizes.borderRadius).r,\n      ),\n      child: Row(\n        mainAxisSize: MainAxisSize.min,\n        crossAxisAlignment: CrossAxisAlignment.center,\n        children: [\n          _PreviousNextButton(\n              onTap: totalPages == 1\n                  ? null\n                  : (isFirstPage ? null : _onPreviousPage)),\n          const SizedBox(width: 7.0).w,\n          ..._builder(),\n          const SizedBox(width: 7.0).w,\n          _PreviousNextButton(\n              isNext: true,\n              onTap:\n                  totalPages == 1 ? null : (isLastPage ? null : _onNextPage)),\n        ],\n      ).spaced(2),\n    );\n  }\n\n  List<Widget> _builder() {\n    final tp = totalPages;\n    final cp = currentPage;\n    final int lim = limit;\n    List<Widget> pages = [];\n\n    if (tp > lim) {\n      if (cp == 1 || cp == 2) {\n        // 1 2 ... 8\n        if (1 == currentPage) {\n          pages.add(_isSelectedBtn());\n        } else {\n          pages.add(_isUnSelectedBtn(1));\n        }\n        if (2 == currentPage) {\n          pages.add(_isSelectedBtn());\n        } else {\n          pages.add(_isUnSelectedBtn(2));\n        }\n        if (3 == currentPage) {\n          pages.add(_isSelectedBtn());\n        } else {\n          pages.add(_isUnSelectedBtn(3));\n        }\n        if (4 == currentPage) {\n          pages.add(_isSelectedBtn());\n        } else {\n          pages.add(_isUnSelectedBtn(4));\n        }\n        if (5 == currentPage) {\n          pages.add(_isSelectedBtn());\n        } else {\n          pages.add(_isUnSelectedBtn(5));\n        }\n        pages.add(_dots());\n        if (tp == currentPage) {\n          pages.add(_isSelectedBtn());\n        } else {\n          pages.add(_isUnSelectedBtn(tp));\n        }\n      } else if (cp > 2 && cp < tp - 1) {\n        // 1 ... 3 ... 8\n        if (currentPage == 1) {\n          pages.add(_isSelectedBtn());\n        } else {\n          pages.add(_isUnSelectedBtn(1));\n        }\n        if (cp == 4 && cp + 2 != currentPage) {\n          pages.add(_isUnSelectedBtn(cp - 2));\n        }\n        if (cp > 4) pages.add(_dots());\n        if (cp + 2 == currentPage) {\n          pages.add(_isSelectedBtn());\n        }\n        if (cp == (tp - 2)) {\n          pages.add(_isUnSelectedBtn(cp - 2)); //adds 6\n        }\n        if (cp - 1 == currentPage) {\n          pages.add(_isSelectedBtn());\n        } else {\n          pages.add(_isUnSelectedBtn(cp - 1));\n        }\n        if (cp == currentPage) {\n          pages.add(_isSelectedBtn());\n        } else {\n          pages.add(_isUnSelectedBtn(cp));\n        }\n        if (cp + 1 == currentPage) {\n          pages.add(_isSelectedBtn());\n        } else {\n          pages.add(_isUnSelectedBtn(cp + 1));\n        }\n        if (cp == 3 && cp + 2 != currentPage) {\n          pages.add(_isUnSelectedBtn(cp + 2));\n        }\n\n        if (cp < tp - 3) pages.add(_dots());\n\n        if (cp == tp - 3) {\n          pages.add(_isUnSelectedBtn(cp + 2));\n        }\n\n        if (tp == currentPage) {\n          pages.add(_isSelectedBtn());\n        } else {\n          pages.add(_isUnSelectedBtn(tp));\n        }\n      } else if (cp == tp - 1 || cp == tp) {\n        // 1 ... 7 8\n        if (1 == currentPage) {\n          pages.add(_isSelectedBtn());\n        } else {\n          pages.add(_isUnSelectedBtn(1));\n        }\n        pages.add(_dots());\n        if (tp - 4 == currentPage) {\n          pages.add(_isSelectedBtn());\n        } else {\n          pages.add(_isUnSelectedBtn(tp - 4));\n        }\n        if (tp - 3 == currentPage) {\n          pages.add(_isSelectedBtn());\n        } else {\n          pages.add(_isUnSelectedBtn(tp - 3));\n        }\n        if (tp - 2 == currentPage) {\n          pages.add(_isSelectedBtn());\n        } else {\n          pages.add(_isUnSelectedBtn(tp - 2));\n        }\n        if (tp - 1 == currentPage) {\n          pages.add(_isSelectedBtn());\n        } else {\n          pages.add(_isUnSelectedBtn(tp - 1));\n        }\n        if (tp == currentPage) {\n          pages.add(_isSelectedBtn());\n        } else {\n          pages.add(_isUnSelectedBtn(tp));\n        }\n      }\n    } else {\n      for (int i = 1; i <= tp; i++) {\n        if (i == currentPage) {\n          pages.add(_isSelectedBtn());\n        } else {\n          pages.add(_isUnSelectedBtn(i));\n        }\n      }\n    }\n\n    return pages;\n  }\n\n  Widget _dots() {\n    return Row(\n      mainAxisSize: MainAxisSize.min,\n      children: [\n        const SizedBox(width: 21.5).w,\n        const Text(\"...\"),\n        const SizedBox(width: 21.5).w,\n      ],\n    );\n  }\n\n  Widget _isSelectedBtn() {\n    return DefaultButton(\n      variant: PrimaryButtonVariant(\n        minimumSize: const Size(50, 50),\n        text: currentPage.toString(),\n        onPressed: () {},\n      ),\n    );\n  }\n\n  Widget _isUnSelectedBtn(int i) {\n    return DefaultButton(\n      variant: GhostButtonVariant(\n        minimumSize: const Size(50, 50),\n        text: i.toString(),\n        onPressed: () => _onNumberTap(i),\n      ),\n    );\n  }\n\n  void _onNumberTap(int i) {\n    onPageChanged(i);\n  }\n\n  void _onPreviousPage() {\n    //If currentPage is 1, then do nothing;\n    //If currentPage is > 1, then set currentPage to currentPage - 1;\n    if (currentPage == 1) {\n      return;\n    }\n    onPageChanged(currentPage - 1);\n  }\n\n  void _onNextPage() {\n    final int lastPage = totalPages;\n\n    //If currentPage is lastPage, then do nothing;\n    //If currentPage is < lastPage, then set currentPage to currentPage + 1;\n\n    if (currentPage == lastPage) {\n      return;\n    }\n    onPageChanged(currentPage + 1);\n  }\n}\n\nclass _PreviousNextButton extends StatelessWidget {\n  final bool isNext;\n  final VoidCallback? onTap;\n\n  const _PreviousNextButton({this.isNext = false, this.onTap});\n\n  @override\n  Widget build(BuildContext context) {\n    if (isNext) {\n      return DefaultButton(\n        variant: IconButtonVariant(\n          iconSize: 12,\n          icon: Icons.arrow_forward_ios,\n          onPressed: onTap,\n        ),\n      );\n    }\n    return DefaultButton(\n      variant: IconButtonVariant(\n        iconSize: 12,\n        icon: Icons.arrow_back_ios,\n        onPressed: onTap,\n      ),\n    );\n  }\n}\n"
  },
  {
    "name": "select",
    "version": "0.0.1",
    "dependencies": [
      "disabled",
      "theme",
      "form",
      "input"
    ],
    "content": "import 'dart:convert';\n\nimport 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nimport 'disabled.dart';\nimport 'form.dart';\nimport 'input.dart';\nimport 'theme.dart';\n\nclass DefaultSelect<T> extends StatefulWidget {\n  final SelectOptions<T> options;\n  final SelectForm<T> form;\n  final SelectDecoration<T> decoration;\n  final SelectNetwork<T>? networkConfig;\n\n  const DefaultSelect({\n    super.key,\n    this.options = const SelectOptions(),\n    required this.form,\n    this.networkConfig,\n    this.decoration = const SelectDecoration(),\n  });\n\n  /// Constructor for DefaultSelect that fetches the options from a network call.\n  /// [networkConfig] is the configuration for the network call.\n  /// [responseParser] is the parser that is used to parse the response from the network call.\n  /// [responseErrorBuilder] is the builder that is used to build the error widget when the network call fails.\n\n  const DefaultSelect.network({\n    super.key,\n    required this.form,\n    this.options = const SelectOptions(),\n    required this.networkConfig,\n    this.decoration = const SelectDecoration(),\n  });\n\n  @override\n  State<DefaultSelect<T>> createState() => _DefaultSelectState<T>();\n}\n\nclass _DefaultSelectState<T> extends State<DefaultSelect<T>> {\n  SelectDecoration<T> get decoration => widget.decoration;\n\n  SelectOptions<T> get dpOptions => widget.options;\n\n  List<ValueItem<T>> get options => widget.options.options;\n\n  SelectForm<T> get form => widget.form;\n\n  SelectNetwork<T>? get networkConfig => widget.networkConfig;\n\n  /// Options list that is used to display the options.\n  final List<ValueItem<T>> _options = [];\n\n  /// Selected options list that is used to display the selected options.\n  final List<ValueItem<T>> _selectedOptions = [];\n\n  /// Disabled options list that is used to display the disabled options.\n  final List<ValueItem<T>> _disabledOptions = [];\n\n  /// The controller for the dropdown.\n  OverlayState? _overlayState;\n  OverlayEntry? _overlayEntry;\n  bool _selectionMode = false;\n\n  late final FocusNode _focusNode;\n  final LayerLink _layerLink = LayerLink();\n\n  /// Response from the network call.\n  dynamic _reponseBody;\n\n  /// value notifier that is used for controller.\n  late SelectController<T> _controller;\n\n  /// search field focus node\n  FocusNode? _searchFocusNode;\n\n  bool get isMultiSelection => decoration.selectionType == SelectionType.multi;\n\n  double get dropdownHeight {\n    double height = 0;\n    for (final option in _options) {\n      height += 43;\n      if (option.subtitle != null) {\n        height += 11;\n      }\n    }\n    return height.h;\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addPostFrameCallback((_) async {\n      await _initialize();\n    });\n\n    _focusNode = FocusNode();\n    _controller = decoration.controller ?? SelectController<T>();\n  }\n\n  /// Initializes the options, selected options and disabled options.\n  /// If the options are fetched from the network, then the network call is made.\n  /// If the options are passed as a parameter, then the options are initialized.\n  Future<void> _initialize() async {\n    if (!mounted) return;\n    if (networkConfig?.networkConfig != null) {\n      await _fetchNetwork();\n    } else {\n      _options.addAll(_controller.options.isNotEmpty == true\n          ? _controller.options\n          : options);\n    }\n    _addOptions();\n    if (mounted) {\n      _initializeOverlay();\n    } else {\n      WidgetsBinding.instance.addPostFrameCallback((timeStamp) {\n        _initializeOverlay();\n      });\n    }\n  }\n\n  @override\n  void didUpdateWidget(covariant DefaultSelect<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    // if (_options != options) {\n    //   _options.clear();\n    //   _options.addAll(options);\n    // }\n  }\n\n  void _initializeOverlay() {\n    _overlayState ??= Overlay.of(context);\n\n    _focusNode.addListener(_handleFocusChange);\n\n    if (decoration.searchEnabled) {\n      _searchFocusNode = FocusNode();\n      _searchFocusNode!.addListener(_handleFocusChange);\n    }\n  }\n\n  /// Adds the selected options and disabled options to the options list.\n  void _addOptions() {\n    setState(() {\n      _selectedOptions.addAll(_controller.selectedOptions.isNotEmpty == true\n          ? _controller.selectedOptions\n          : dpOptions.selectedOptions);\n      _disabledOptions.addAll(_controller.disabledOptions.isNotEmpty == true\n          ? _controller.disabledOptions\n          : dpOptions.disabledOptions);\n    });\n\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      if (_controller._isDisposed == false) {\n        _controller.setOptions(_options);\n        _controller.setSelectedOptions(_selectedOptions);\n        _controller.setDisabledOptions(_disabledOptions);\n\n        _controller.addListener(_handleControllerChange);\n      }\n    });\n  }\n\n  /// Handles the focus change to show/hide the dropdown.\n  void _handleFocusChange() {\n    if (_focusNode.hasFocus && mounted) {\n      _overlayEntry = _buildOverlayEntry();\n      Overlay.of(context).insert(_overlayEntry!);\n      _updateSelection();\n      return;\n    }\n\n    if ((_searchFocusNode == null || _searchFocusNode?.hasFocus == false) &&\n        _overlayEntry != null) {\n      _overlayEntry?.remove();\n      // ignore: invalid_use_of_protected_member, invalid_use_of_visible_for_testing_member\n      _controller.notifyListeners();\n    }\n\n    if (mounted) _updateSelection();\n\n    _controller.value._isDropdownOpen =\n        _focusNode.hasFocus || _searchFocusNode?.hasFocus == true;\n    // ignore: invalid_use_of_protected_member, invalid_use_of_visible_for_testing_member\n    _controller.notifyListeners();\n  }\n\n  void _updateSelection() {\n    setState(() {\n      _selectionMode =\n          _focusNode.hasFocus || _searchFocusNode?.hasFocus == true;\n    });\n  }\n\n  /// Calculate offset size for dropdown.\n  List _calculateOffsetSize() {\n    RenderBox? renderBox = context.findRenderObject() as RenderBox?;\n\n    var size = renderBox?.size ?? Size.zero;\n    var offset = renderBox?.localToGlobal(Offset.zero) ?? Offset.zero;\n\n    final availableHeight = MediaQuery.of(context).size.height - offset.dy;\n\n    if (decoration.customWidget != null) {\n      return [\n        decoration.dropdownMenuSize ?? const Size.fromWidth(300),\n        availableHeight < dropdownHeight,\n      ];\n    }\n\n    return [\n      decoration.dropdownMenuSize ?? size,\n      availableHeight < dropdownHeight,\n    ];\n  }\n\n  /// Dispose the focus node and overlay entry.\n  @override\n  void dispose() {\n    if (_overlayEntry?.mounted == true) {\n      if (_overlayState != null && _overlayEntry != null) {\n        _overlayEntry?.remove();\n      }\n      _overlayEntry = null;\n      _overlayState?.dispose();\n    }\n    _focusNode.removeListener(_handleFocusChange);\n    _searchFocusNode?.removeListener(_handleFocusChange);\n    _focusNode.dispose();\n    _searchFocusNode?.dispose();\n    _controller.removeListener(_handleControllerChange);\n\n    if (decoration.controller == null ||\n        decoration.controller?.isDisposed == true) {\n      _controller.dispose();\n    }\n\n    super.dispose();\n  }\n\n  /// Util method to map with index.\n  Iterable<E> mapIndexed<E, F>(\n      Iterable<F> items, E Function(int index, F item) f) sync* {\n    var index = 0;\n\n    for (final item in items) {\n      yield f(index, item);\n      index = index + 1;\n    }\n  }\n\n  /// Handle the focus change on tap outside of the dropdown.\n  void _onOutSideTap() {\n    if (_searchFocusNode != null) {\n      _searchFocusNode!.unfocus();\n    }\n    _focusNode.unfocus();\n  }\n\n  /// Method to toggle the focus of the dropdown.\n  void _toggleFocus() {\n    if (_focusNode.hasFocus) {\n      _focusNode.unfocus();\n    } else {\n      _focusNode.requestFocus();\n    }\n  }\n\n  /// Clear the selected options.\n  /// [SelectController] is used to clear the selected options.\n  void clear() {\n    if (!_controller._isDisposed) {\n      _controller.clearAllSelection();\n    } else {\n      setState(() {\n        _selectedOptions.clear();\n      });\n      dpOptions.onOptionSelected?.call(_selectedOptions);\n    }\n    if (_focusNode.hasFocus) _focusNode.unfocus();\n  }\n\n  /// handle the controller change.\n  void _handleControllerChange() {\n    // if the controller is null, return.\n    if (_controller.isDisposed == true) return;\n\n    // if current disabled options are not equal to the controller's disabled options, update the state.\n    if (_disabledOptions != _controller.value._disabledOptions) {\n      setState(() {\n        _disabledOptions.clear();\n        _disabledOptions.addAll(_controller.value._disabledOptions);\n      });\n    }\n\n    // if current options are not equal to the controller's options, update the state.\n    if (_options != _controller.value._options) {\n      setState(() {\n        _options.clear();\n        _options.addAll(_controller.value._options);\n      });\n    }\n\n    // if current selected options are not equal to the controller's selected options, update the state.\n    if (_selectedOptions != _controller.value._selectedOptions) {\n      setState(() {\n        _selectedOptions.clear();\n        _selectedOptions.addAll(_controller.value._selectedOptions);\n      });\n      dpOptions.onOptionSelected?.call(_selectedOptions);\n    }\n\n    if (_selectionMode != _controller.value._isDropdownOpen) {\n      if (_controller.value._isDropdownOpen) {\n        _focusNode.requestFocus();\n      } else {\n        _focusNode.unfocus();\n      }\n    }\n  }\n\n  bool isLoading = false;\n\n  /// Make a request to the provided url.\n  /// The response then is parsed to a list of ValueItem objects.\n  Future<void> _fetchNetwork() async {\n    setState(() {\n      isLoading = true;\n    });\n    final result = await _performNetworkRequest();\n    get(Uri.parse(networkConfig!.networkConfig!.url));\n    if (result.statusCode == 200) {\n      final data = json.decode(result.body);\n      final List<ValueItem<T>> parsedOptions =\n          await networkConfig!.responseParser!(data);\n      _reponseBody = null;\n      _options.addAll(parsedOptions);\n    } else {\n      _reponseBody = result.body;\n    }\n    setState(() {\n      isLoading = false;\n    });\n  }\n\n  /// Perform the network request according to the provided configuration.\n  Future<Response> _performNetworkRequest() async {\n    switch (networkConfig!.networkConfig!.method) {\n      case RequestMethod.get:\n        return await get(\n          Uri.parse(networkConfig!.networkConfig!.url),\n          headers: networkConfig!.networkConfig!.headers,\n        );\n      case RequestMethod.post:\n        return await post(\n          Uri.parse(networkConfig!.networkConfig!.url),\n          body: networkConfig!.networkConfig!.body,\n          headers: networkConfig!.networkConfig!.headers,\n        );\n      case RequestMethod.put:\n        return await put(\n          Uri.parse(networkConfig!.networkConfig!.url),\n          body: networkConfig!.networkConfig!.body,\n          headers: networkConfig!.networkConfig!.headers,\n        );\n      case RequestMethod.patch:\n        return await patch(\n          Uri.parse(networkConfig!.networkConfig!.url),\n          body: networkConfig!.networkConfig!.body,\n          headers: networkConfig!.networkConfig!.headers,\n        );\n      case RequestMethod.delete:\n        return await delete(\n          Uri.parse(networkConfig!.networkConfig!.url),\n          headers: networkConfig!.networkConfig!.headers,\n        );\n      default:\n        return await get(\n          Uri.parse(networkConfig!.networkConfig!.url),\n          headers: networkConfig!.networkConfig!.headers,\n        );\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ThemeProvider(builder: (context, themeVm) {\n      return Theme(\n        data: themeVm.theme,\n        child: DefaultDisabled(\n          vm: DisabledVm(\n              disabled: isLoading || decoration.disabled,\n              child: Semantics(\n                button: true,\n                enabled: true,\n                child: CompositedTransformTarget(\n                  link: _layerLink,\n                  child: Focus(\n                    canRequestFocus: true,\n                    skipTraversal: true,\n                    focusNode: _focusNode,\n                    child: FormBuilderField<List<ValueItem<T>>>(\n                        name: form.name,\n                        validator: (value) {\n                          if (value == null) return null;\n                          return form.validator?.call(value);\n                        },\n                        initialValue: _selectedOptions,\n                        onChanged: (value) {\n                          if (value != null) {\n                            dpOptions.onOptionSelected?.call(value);\n                          }\n                        },\n                        enabled: !decoration.disabled,\n                        builder: (field) {\n                          final errorText = field.errorText;\n                          final hasError = errorText != null;\n                          return Column(\n                            crossAxisAlignment: CrossAxisAlignment.start,\n                            mainAxisSize: MainAxisSize.min,\n                            children: [\n                              InkWell(\n                                splashFactory: NoSplash.splashFactory,\n                                overlayColor: MaterialStatePropertyAll(\n                                    FcnuiDefaultColor(context).borderColor),\n                                radius: FcnuiDefaultSizes.borderRadius,\n                                borderRadius: BorderRadius.circular(\n                                    FcnuiDefaultSizes.borderRadius),\n                                onTap: _toggleFocus,\n                                child: decoration.customWidget ??\n                                    AnimatedContainer(\n                                      duration:\n                                          const Duration(milliseconds: 200),\n                                      height:\n                                          decoration.wrapType == WrapType.wrap\n                                              ? null\n                                              : decoration.height?.h ?? 50.h,\n                                      constraints: BoxConstraints(\n                                        minWidth:\n                                            MediaQuery.of(context).size.width,\n                                        minHeight: decoration.height?.h ?? 50.h,\n                                      ),\n                                      padding: _getContainerPadding(),\n                                      decoration: _getContainerDecoration(\n                                          themeVm.theme, hasError),\n                                      child: Row(\n                                        crossAxisAlignment:\n                                            CrossAxisAlignment.center,\n                                        children: [\n                                          Expanded(\n                                              child: _getContainerContent()),\n                                          if (_anyItemSelected) ...[\n                                            const SizedBox(\n                                                    width: FcnuiDefaultSizes\n                                                        .itemSpacing)\n                                                .w,\n                                            if (isMultiSelection &&\n                                                decoration.showClearIcon)\n                                              InkWell(\n                                                  onTap: () => clear(),\n                                                  child: const Icon(\n                                                    Icons.close,\n                                                    size: FcnuiDefaultSizes\n                                                        .iconSize,\n                                                  )),\n                                            const SizedBox(\n                                                    width: FcnuiDefaultSizes\n                                                        .itemSpacing)\n                                                .w\n                                          ],\n                                          _buildSuffixIcon(),\n                                        ],\n                                      ),\n                                    ),\n                              ),\n                              if (hasError)\n                                Padding(\n                                  padding: const EdgeInsets.only(top: 4.0),\n                                  child: Text(\n                                    errorText,\n                                    style: TextStyle(\n                                      color:\n                                          FcnuiDefaultColor(context).errorColor,\n                                      fontSize: 12.sp,\n                                    ),\n                                  ),\n                                ),\n                            ],\n                          );\n                        }),\n                  ),\n                ),\n              )),\n        ),\n      );\n    });\n  }\n\n  Widget _buildSuffixIcon() {\n    return AnimatedRotation(\n      turns: _selectionMode ? 0.5 : 0,\n      duration: const Duration(milliseconds: 200),\n      child: isLoading\n          ? const Center(child: CircularProgressIndicator())\n          : Icon(\n              Icons.keyboard_arrow_down_outlined,\n              size: FcnuiDefaultSizes.iconSize,\n              color: FcnuiDefaultColor(context).greyColor,\n            ),\n    );\n  }\n\n  /// Container Content for the dropdown.\n  Widget _getContainerContent() {\n    Widget column(String? value, Widget? child, {bool isGrey = false}) {\n      return Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        mainAxisSize: MainAxisSize.min,\n        children: [\n          if (decoration.labelText != null)\n            Text(\n              decoration.labelText!,\n              style: Theme.of(context).textTheme.bodySmall,\n            ),\n          if (value != null)\n            Text(\n              value,\n              maxLines: 1,\n              overflow: TextOverflow.ellipsis,\n              style: Theme.of(context).textTheme.bodyMedium!.copyWith(\n                  color: isGrey ? FcnuiDefaultColor(context).greyColor : null),\n            ),\n          if (child != null) child,\n        ],\n      );\n    }\n\n    if (_selectedOptions.isEmpty ||\n        decoration.showSelectedValuesContent == false) {\n      return column(decoration.hintText, null, isGrey: true);\n    }\n\n    if (decoration.selectionType == SelectionType.single) {\n      return column(_selectedOptions.first.label, null);\n    }\n\n    return column(null, _buildSelectedItems());\n  }\n\n  /// return true if any item is selected.\n  bool get _anyItemSelected => _selectedOptions.isNotEmpty;\n\n  /// Container decoration for the dropdown.\n  Decoration _getContainerDecoration(ThemeData theme, bool hasError) {\n    return BoxDecoration(\n      color: decoration.isColorful\n          ? theme.colorScheme.primary.withOpacity(.1)\n          : FcnuiDefaultColor(context).borderColor,\n      borderRadius: BorderRadius.circular(FcnuiDefaultSizes.borderRadius).r,\n      border: Border.all(\n              strokeAlign: BorderSide.strokeAlignOutside,\n              color: hasError\n                  ? FcnuiDefaultColor(context).errorColor\n                  : (_selectionMode ? theme.primaryColor : Colors.transparent),\n              width: _selectionMode\n                  ? FcnuiDefaultSizes.selectedBorderWidth\n                  : FcnuiDefaultSizes.borderWidth)\n          .w,\n    );\n  }\n\n  /// Build the selected items for the dropdown.\n  Widget _buildSelectedItems() {\n    if (decoration.wrapType == WrapType.ellipsis) {\n      final List<String> texts = [];\n      for (final item in _selectedOptions) {\n        texts.add(item.label);\n      }\n      return Text(\n        texts.join(\", \"),\n        maxLines: 1,\n        overflow: TextOverflow.ellipsis,\n        style: Theme.of(context).textTheme.bodyMedium,\n      );\n    }\n    return Wrap(\n        spacing: FcnuiDefaultSizes.itemSpacing,\n        runSpacing: FcnuiDefaultSizes.itemSpacing,\n        children: mapIndexed(_selectedOptions, (index, item) {\n          return _buildSelectedItem(\n              _selectedOptions[index],\n              !_disabledOptions.contains(_selectedOptions[index]),\n              index == _selectedOptions.length - 1);\n        }).toList());\n  }\n\n  /// Build the selected item chip.\n  Widget _buildSelectedItem(ValueItem<T> item, bool isEnabled, bool isLast) {\n    return Text(\n      \"${item.label}${isLast ? \"\" : \",\"}\",\n      style: const TextStyle(fontWeight: FontWeight.normal),\n      overflow: TextOverflow.ellipsis,\n      maxLines: 1,\n    );\n  }\n\n  /// Get the selectedItem icon for the dropdown\n  Widget? _getSelectedIcon(bool isSelected, ThemeData theme) {\n    return AnimatedOpacity(\n      opacity: isSelected ? 1 : 0,\n      duration: const Duration(milliseconds: 200),\n      child: Icon(\n        Icons.check,\n        color: decoration.isColorful\n            ? theme.primaryColor\n            : theme.colorScheme.onSurface,\n        size: FcnuiDefaultSizes.iconSize,\n      ),\n    );\n  }\n\n  Widget buildTransparentBox() {\n    return Positioned.fill(\n      child: GestureDetector(\n        behavior: HitTestBehavior.translucent,\n        onTap: _onOutSideTap,\n        child: const ColoredBox(\n          color: Colors.transparent,\n        ),\n      ),\n    );\n  }\n\n  /// Create the overlay entry for the dropdown.\n  OverlayEntry _buildOverlayEntry() {\n    // Calculate the offset and the size of the dropdown button\n    final values = _calculateOffsetSize();\n    // Get the size from the first item in the values list\n    final size = values[0] as Size;\n    // Get the showOnTop value from the second item in the values list\n    final showOnTop = values[1] as bool;\n\n    return OverlayEntry(builder: (context) {\n      List<ValueItem<T>> options = _options;\n      List<ValueItem<T>> selectedOptions = [..._selectedOptions];\n      final theme = Theme.of(context);\n\n      return StatefulBuilder(builder: ((context, dropdownState) {\n        return Stack(\n          children: [\n            buildTransparentBox(),\n            CompositedTransformFollower(\n              link: _layerLink,\n              showWhenUnlinked: true,\n              targetAnchor:\n                  showOnTop ? Alignment.topLeft : Alignment.bottomLeft,\n              followerAnchor:\n                  showOnTop ? Alignment.bottomLeft : Alignment.topLeft,\n              offset: Offset(0, showOnTop ? -5 : 5).w,\n              child: Material(\n                  elevation: 1,\n                  color: theme.colorScheme.surface,\n                  shape: RoundedRectangleBorder(\n                    borderRadius: BorderRadius.all(\n                      Radius.circular(FcnuiDefaultSizes.borderRadius.r),\n                    ),\n                    side: BorderSide(\n                        strokeAlign: BorderSide.strokeAlignInside,\n                        color: FcnuiDefaultColor(context).borderColor,\n                        width: FcnuiDefaultSizes.borderWidth),\n                  ),\n                  shadowColor: Colors.black12,\n                  child: Container(\n                    decoration: BoxDecoration(\n                      color: theme.dividerColor.withOpacity(.2),\n                      borderRadius: BorderRadius.circular(\n                          FcnuiDefaultSizes.borderRadius.r),\n                    ),\n                    constraints: decoration.searchEnabled\n                        ? BoxConstraints.loose(Size(\n                            size.width,\n                            (decoration.dropdownMenuMaxHeight ??\n                                    dropdownHeight) +\n                                50))\n                        : BoxConstraints.loose(Size(\n                            size.width,\n                            (decoration.dropdownMenuMaxHeight ??\n                                dropdownHeight))),\n                    child: _reponseBody != null && widget.networkConfig != null\n                        ? Center(\n                            child: networkConfig!.responseErrorBuilder!(\n                                context, _reponseBody),\n                          )\n                        : Column(\n                            mainAxisSize: MainAxisSize.min,\n                            children: [\n                              if (decoration.searchEnabled) ...[\n                                ColoredBox(\n                                  color: theme.dividerColor.withOpacity(.1),\n                                  child: Padding(\n                                    padding: const EdgeInsets.all(4.0).w,\n                                    child: DefaultInput(\n                                      vm: InputModel(\n                                        name: \"search\",\n                                        focusNode: _searchFocusNode,\n                                        onChanged: (value) {\n                                          if (value == null) return;\n                                          dropdownState(() {\n                                            options = _options.where((element) {\n                                              final label =\n                                                  element.label.toLowerCase();\n                                              final search =\n                                                  value.toLowerCase();\n                                              final subtitle = element.subtitle\n                                                      ?.toLowerCase() ??\n                                                  \"\";\n                                              return label.contains(search) ||\n                                                  subtitle.contains(search);\n                                            }).toList();\n                                          });\n                                        },\n                                        hintText:\n                                            decoration.hintText ?? \"Search\",\n                                      ),\n                                    ),\n                                  ),\n                                ),\n                                Divider(height: 1.h),\n                              ],\n                              if (_options.isEmpty || options.isEmpty)\n                                Expanded(\n                                  child: Center(\n                                    child: Text(\n                                      \"Not found\",\n                                      style: theme.textTheme.bodyMedium,\n                                    ),\n                                  ),\n                                )\n                              else\n                                Expanded(\n                                  child: ListView.separated(\n                                    physics: const ClampingScrollPhysics(),\n                                    separatorBuilder: (_, __) => SizedBox(\n                                            height: isMultiSelection ? 2 : 0)\n                                        .w,\n                                    padding: const EdgeInsets.all(4).w,\n                                    itemCount: options.length,\n                                    itemBuilder: (context, index) {\n                                      final option = options[index];\n                                      final isSelected =\n                                          selectedOptions.contains(option);\n\n                                      onTap() {\n                                        if (decoration.selectionType ==\n                                            SelectionType.multi) {\n                                          if (isSelected) {\n                                            dropdownState(() {\n                                              selectedOptions.remove(option);\n                                            });\n                                            setState(() {\n                                              _selectedOptions.remove(option);\n                                            });\n                                            dpOptions.onOptionRemoved\n                                                ?.call(index, option);\n                                          } else {\n                                            final bool hasReachMax =\n                                                dpOptions.maxItems == null\n                                                    ? false\n                                                    : (_selectedOptions.length +\n                                                            1) >\n                                                        dpOptions.maxItems!;\n                                            if (hasReachMax) return;\n\n                                            dropdownState(() {\n                                              selectedOptions.add(option);\n                                            });\n                                            setState(() {\n                                              _selectedOptions.add(option);\n                                            });\n                                          }\n                                        } else {\n                                          dropdownState(() {\n                                            selectedOptions.clear();\n                                            selectedOptions.add(option);\n                                          });\n                                          setState(() {\n                                            _selectedOptions.clear();\n                                            _selectedOptions.add(option);\n                                          });\n                                        }\n                                        _focusNode.unfocus();\n\n                                        _controller.value._selectedOptions\n                                            .clear();\n                                        _controller.value._selectedOptions\n                                            .addAll(_selectedOptions);\n\n                                        dpOptions.onOptionSelected\n                                            ?.call(_selectedOptions);\n                                      }\n\n                                      if (decoration.optionBuilder != null) {\n                                        return InkWell(\n                                          onTap: onTap,\n                                          splashFactory: NoSplash.splashFactory,\n                                          child: decoration.optionBuilder!(\n                                              context, option, isSelected),\n                                        );\n                                      }\n\n                                      final primaryColor =\n                                          Theme.of(context).primaryColor;\n\n                                      return _buildOption(\n                                        option: option,\n                                        primaryColor: primaryColor,\n                                        isSelected: isSelected,\n                                        dropdownState: dropdownState,\n                                        onTap: onTap,\n                                        selectedOptions: selectedOptions,\n                                        theme: Theme.of(context),\n                                      );\n                                    },\n                                  ),\n                                ),\n                            ],\n                          ),\n                  )),\n            ),\n          ],\n        );\n      }));\n    });\n  }\n\n  Widget _buildOption(\n      {required ValueItem<T> option,\n      required Color primaryColor,\n      required bool isSelected,\n      required StateSetter dropdownState,\n      required void Function() onTap,\n      required List<ValueItem<T>> selectedOptions,\n      required ThemeData theme}) {\n    bool enabled = true;\n\n    //if disabled contains the option, then it is disabled.\n    if (_disabledOptions.contains(option)) {\n      enabled = false;\n    }\n\n    bool hasReachedMax = dpOptions.maxItems == null\n        ? false\n        : (_selectedOptions.length + 1) > dpOptions.maxItems!;\n    //if _selectedOptions.length is equal to maxItems, then it is disabled.\n    if (hasReachedMax) {\n      if (isSelected == false) {\n        enabled = false;\n      }\n    }\n\n    if (dpOptions.optionItemBuilder != null) {\n      return DefaultDisabled(\n          vm: DisabledVm(\n        disabled: !enabled,\n        child: InkWell(\n          onTap: onTap,\n          splashFactory: NoSplash.splashFactory,\n          child: dpOptions.optionItemBuilder!(context, option, isSelected),\n        ),\n      ));\n    }\n\n    return ListTile(\n      key: ValueKey(option.value),\n      splashColor: Colors.transparent,\n      mouseCursor:\n          enabled ? SystemMouseCursors.click : SystemMouseCursors.forbidden,\n      title: Text(option.label),\n      subtitle: option.subtitle != null ? Text(option.subtitle!) : null,\n      horizontalTitleGap: 10.w,\n      titleTextStyle: theme.textTheme.bodyMedium,\n      subtitleTextStyle: theme.textTheme.bodySmall!\n          .copyWith(color: theme.colorScheme.onSurface.withOpacity(0.6)),\n      selectedColor:\n          decoration.isColorful ? primaryColor : theme.colorScheme.onSurface,\n      selected: isSelected,\n      autofocus: true,\n      dense: true,\n      contentPadding: const EdgeInsets.symmetric(horizontal: 8, vertical: 0).w,\n      shape: RoundedRectangleBorder(\n          borderRadius:\n              BorderRadius.circular(FcnuiDefaultSizes.borderRadius).r),\n      tileColor: theme.colorScheme.surface,\n      selectedTileColor: decoration.isColorful\n          ? theme.primaryColor.withOpacity(.1)\n          : FcnuiDefaultColor(context).borderColor,\n      enabled: enabled,\n      onTap: onTap,\n      trailing: _getSelectedIcon(isSelected, theme),\n      leading: option.icon,\n    );\n  }\n\n  // get the container padding.\n  EdgeInsetsGeometry _getContainerPadding() {\n    if (decoration.selectionType == SelectionType.single) {\n      return const EdgeInsets.symmetric(\n              horizontal: FcnuiDefaultSizes.paddingHorizontal)\n          .w;\n    } else {\n      return const EdgeInsets.symmetric(\n              horizontal: FcnuiDefaultSizes.paddingHorizontal)\n          .w;\n    }\n  }\n}\n\n/// [SelectionType]\n/// SelectionType enum for the selection type of the dropdown items.\n/// * [single]: single selection\n/// * [multi]: multi selection\nenum SelectionType {\n  single,\n  multi,\n}\n\n/// [WrapType]\n/// WrapType enum for the wrap type of the selected items.\n/// * [WrapType.scroll]: scroll the selected items horizontally\n/// * [WrapType.wrap]: wrap the selected items in both directions\nenum WrapType { ellipsis, wrap }\n\n/// [RequestMethod]\n/// RequestMethod enum for the request method of the dropdown items.\n/// * [RequestMethod.get]: get request\n/// * [RequestMethod.post]: post request\n/// * [RequestMethod.put]: put request\n/// * [RequestMethod.delete]: delete request\n/// * [RequestMethod.patch]: patch request\nenum RequestMethod { get, post, put, patch, delete }\n\n/// Configuration for the network.\n///\n/// [url] is the url of the network.\n/// [method] is the request method of the network.\n/// [headers] is the headers of the network.\n/// [body] is the body of the network.\n/// [queryParameters] is the query parameters of the network.\n\nclass NetworkConfig {\n  final String url;\n  final RequestMethod method;\n  final Map<String, String>? headers;\n  final Map<String, dynamic>? body;\n  final Map<String, dynamic>? queryParameters;\n\n  NetworkConfig({\n    required this.url,\n    this.method = RequestMethod.get,\n    this.headers = const {},\n    this.body,\n    this.queryParameters = const {},\n  });\n}\n\n/// [label] is the item that is displayed in the list. [value] is the value that is returned when the item is selected.\n/// If the [value] is not provided, the [label] is used as the value.\n/// An example of a [ValueItem] is:\n/// ```dart\n/// const ValueItem(label: 'Option 1', value: '1')\n/// ```\n\nclass ValueItem<T> extends Equatable {\n  /// The label of the value item\n  final String label;\n\n  final String? subtitle;\n\n  /// The value of the value item\n  final T? value;\n\n  final Widget? icon;\n\n  /// Default constructor for [ValueItem]\n  const ValueItem(\n      {required this.label, required this.value, this.subtitle, this.icon});\n\n  /// toString method for [ValueItem]\n  @override\n  String toString() {\n    return 'ValueItem(label: $label, value: $value, subtitle: $subtitle)';\n  }\n\n  /// toMap method for [ValueItem]\n  Map<String, dynamic> toMap() {\n    return {\n      'label': label,\n      'value': value,\n      'subtitle': subtitle,\n      'icon': icon,\n    };\n  }\n\n  /// fromMap method for [ValueItem]\n  factory ValueItem.fromMap(Map<String, dynamic> map) {\n    return ValueItem<T>(\n      label: map['label'] ?? '',\n      value: map['value'],\n      subtitle: map['subtitle'],\n      icon: map['icon'],\n    );\n  }\n\n  /// toJson method for [ValueItem]\n  String toJson() => json.encode(toMap());\n\n  /// fromJson method for [ValueItem]\n  factory ValueItem.fromJson(String source) =>\n      ValueItem<T>.fromMap(json.decode(source));\n\n  /// CopyWith method for [ValueItem]\n  ValueItem<T> copyWith({\n    String? label,\n    T? value,\n    String? subtitle,\n    Widget? icon,\n  }) {\n    return ValueItem<T>(\n      label: label ?? this.label,\n      value: value ?? this.value,\n      subtitle: subtitle ?? this.subtitle,\n      icon: icon ?? this.icon,\n    );\n  }\n\n  @override\n  List<Object?> get props => [label, value, subtitle, icon];\n}\n\ntypedef OnOptionSelected<T> = void Function(List<ValueItem<T>> selectedOptions);\n\nclass SelectDecoration<T> extends Equatable {\n  final String? hintText;\n\n  final String? labelText;\n\n  // selection type of the dropdown\n  final SelectionType selectionType;\n\n  // options configuration\n  final double? dropdownHeight;\n\n  /// Controller for the dropdown\n  /// [controller] is the controller for the dropdown. It can be used to programmatically open and close the dropdown.\n  final SelectController<T>? controller;\n\n  /// Enable search\n  /// [searchEnabled] is the flag to enable search in dropdown. It is used to show search bar in dropdown.\n  final bool searchEnabled;\n\n  /// Use this if [customWidget] is provided\n  ///\n  /// Else it will calculate the size of the dropdown based on\n  ///\n  /// the size of the widget\n  final Size? dropdownMenuSize;\n\n  final double? dropdownMenuMaxHeight;\n\n  final Widget? customWidget;\n\n  final bool disabled;\n\n  /// option builder\n  /// [optionBuilder] is the builder that is used to build the option item.\n  /// The builder takes three arguments, the context, the option and the selected status of the option.\n  /// The builder returns a widget.\n  ///\n\n  final Widget Function(BuildContext ctx, ValueItem<T> option, bool selected)?\n      optionBuilder;\n\n  final WrapType wrapType;\n\n  final bool showSelectedValuesContent;\n\n  final bool showClearIcon;\n\n  final bool isColorful;\n\n  final double? height;\n\n  const SelectDecoration({\n    this.hintText,\n    this.selectionType = SelectionType.single,\n    this.dropdownHeight,\n    this.height,\n    this.showClearIcon = false,\n    this.showSelectedValuesContent = true,\n    this.controller,\n    this.searchEnabled = false,\n    this.dropdownMenuSize,\n    this.dropdownMenuMaxHeight,\n    this.customWidget,\n    this.optionBuilder,\n    this.wrapType = WrapType.ellipsis,\n    this.disabled = false,\n    this.labelText,\n    this.isColorful = false,\n  });\n\n  @override\n  List<Object?> get props => [\n        hintText,\n        selectionType,\n        dropdownHeight,\n        controller,\n        searchEnabled,\n        dropdownMenuSize,\n        dropdownMenuMaxHeight,\n        customWidget,\n        wrapType,\n        disabled,\n        labelText,\n        showSelectedValuesContent,\n        showClearIcon,\n        isColorful,\n        height,\n      ];\n}\n\nclass SelectForm<T> extends IFormModel {\n  const SelectForm({\n    required super.name,\n    this.validator,\n  });\n\n  //validator\n  final String? Function(List<ValueItem<T>>)? validator;\n\n  @override\n  List<Object?> get props => [name, validator];\n}\n\nclass SelectOptions<T> extends Equatable {\n  final List<ValueItem<T>> options;\n  final List<ValueItem<T>> selectedOptions;\n  final List<ValueItem<T>> disabledOptions;\n\n  final OnOptionSelected<T>? onOptionSelected;\n\n  /// [onOptionRemoved] is the callback that is called when an option is removed.The callback takes two arguments, the index of the removed option and the removed option.\n  /// This will be called only when the delete icon is clicked on the option chip.\n  ///\n  /// This will not be called when the option is removed programmatically.\n  ///\n  /// ```index``` is the index of the removed option.\n  ///\n  /// ```option``` is the removed option.\n  final void Function(int index, ValueItem<T> option)? onOptionRemoved;\n\n  /// Maximum number of items that can be selected\n  final int? maxItems;\n\n  final Widget Function(BuildContext context, ValueItem<T>, bool isSelected)?\n      optionItemBuilder;\n\n  const SelectOptions({\n    this.options = const [],\n    this.selectedOptions = const [],\n    this.disabledOptions = const [],\n    this.onOptionSelected,\n    this.onOptionRemoved,\n    this.maxItems,\n    this.optionItemBuilder,\n  });\n\n  @override\n  List<Object?> get props => [\n        options,\n        selectedOptions,\n        disabledOptions,\n        maxItems,\n      ];\n}\n\nclass SelectNetwork<T> extends Equatable {\n  const SelectNetwork({\n    required this.networkConfig,\n    required this.responseParser,\n    this.responseErrorBuilder,\n  });\n\n  final NetworkConfig? networkConfig;\n  final Future<List<ValueItem<T>>> Function(dynamic)? responseParser;\n  final Widget Function(BuildContext, dynamic)? responseErrorBuilder;\n\n  @override\n  List<Object?> get props =>\n      [networkConfig, responseParser, responseErrorBuilder];\n}\n\n/// MultiSelect Controller class.\n/// This class is used to control the state of the MultiDefaultSelect widget.\n/// This is just base class. The implementation of this class is in the SelectController class.\n/// The implementation of this class is hidden from the user.\nclass _SelectController<T> {\n  final List<ValueItem<T>> _disabledOptions = [];\n  final List<ValueItem<T>> _options = [];\n  final List<ValueItem<T>> _selectedOptions = [];\n  bool _isDropdownOpen = false;\n}\n\n/// implementation of the SelectController class.\nclass SelectController<T> extends ValueNotifier<_SelectController<T>> {\n  SelectController() : super(_SelectController());\n\n  bool _isDisposed = false;\n\n  bool get isDisposed => _isDisposed;\n\n  /// set the dispose method.\n  @override\n  void dispose() {\n    super.dispose();\n    _isDisposed = true;\n  }\n\n  /// Clear the selected options.\n  /// [SelectController] is used to clear the selected options.\n  void clearAllSelection() {\n    value._selectedOptions.clear();\n    notifyListeners();\n  }\n\n  /// clear specific selected option\n  /// [SelectController] is used to clear specific selected option.\n  void clearSelection(ValueItem<T> option) {\n    if (!value._selectedOptions.contains(option)) return;\n\n    if (value._disabledOptions.contains(option)) {\n      throw Exception('Cannot clear selection of a disabled option');\n    }\n\n    if (!value._options.contains(option)) {\n      throw Exception(\n          'Cannot clear selection of an option that is not in the options list');\n    }\n\n    value._selectedOptions.remove(option);\n    notifyListeners();\n  }\n\n  /// select the options\n  /// [SelectController] is used to select the options.\n  void setSelectedOptions(List<ValueItem<T>> options) {\n    if (options.any((element) => value._disabledOptions.contains(element))) {\n      throw Exception('Cannot select disabled options');\n    }\n\n    if (options.any((element) => !value._options.contains(element))) {\n      throw Exception('Cannot select options that are not in the options list');\n    }\n\n    value._selectedOptions.clear();\n    value._selectedOptions.addAll(options);\n    notifyListeners();\n  }\n\n  /// add selected option\n  /// [SelectController] is used to add selected option.\n  void addSelectedOption(ValueItem<T> option) {\n    if (value._disabledOptions.contains(option)) {\n      throw Exception('Cannot select disabled option');\n    }\n\n    if (!value._options.contains(option)) {\n      throw Exception('Cannot select option that is not in the options list');\n    }\n\n    value._selectedOptions.add(option);\n    notifyListeners();\n  }\n\n  /// set disabled options\n  /// [SelectController] is used to set disabled options.\n  void setDisabledOptions(List<ValueItem<T>> disabledOptions) {\n    if (disabledOptions.any((element) => !value._options.contains(element))) {\n      throw Exception(\n          'Cannot disable options that are not in the options list');\n    }\n\n    value._disabledOptions.clear();\n    value._disabledOptions.addAll(disabledOptions);\n    notifyListeners();\n  }\n\n  /// setDisabledOption method\n  /// [SelectController] is used to set disabled option.\n  void setDisabledOption(ValueItem<T> disabledOption) {\n    if (!value._options.contains(disabledOption)) {\n      throw Exception('Cannot disable option that is not in the options list');\n    }\n\n    value._disabledOptions.add(disabledOption);\n    notifyListeners();\n  }\n\n  /// set options\n  /// [SelectController] is used to set options.\n  void setOptions(List<ValueItem<T>> options) {\n    value._options.clear();\n    value._options.addAll(options);\n    notifyListeners();\n  }\n\n  /// get disabled options\n  List<ValueItem<T>> get disabledOptions => value._disabledOptions;\n\n  /// get enabled options\n  List<ValueItem<T>> get enabledOptions => value._options\n      .where((element) => !value._disabledOptions.contains(element))\n      .toList();\n\n  /// get options\n  List<ValueItem<T>> get options => value._options;\n\n  /// get selected options\n  List<ValueItem<T>> get selectedOptions => value._selectedOptions;\n\n  /// get is dropdown open\n  bool get isDropdownOpen => value._isDropdownOpen;\n\n  /// open dropdown\n  /// [SelectController] is used to open dropdown.\n  void openDropdown() {\n    if (value._isDropdownOpen) return;\n    value._isDropdownOpen = true;\n    notifyListeners();\n  }\n\n  /// close dropdown\n  /// [SelectController] is used to close dropdown.\n  void closeDropdown() {\n    if (!value._isDropdownOpen) return;\n    value._isDropdownOpen = false;\n    notifyListeners();\n  }\n}\n"
  },
  {
    "name": "theme",
    "version": "0.0.1",
    "content": "import 'package:fcnui_base/fcnui_base.dart';\nimport 'package:flutter/material.dart';\n\nabstract class FcnuiDefaultSizes {\n  static const double borderRadius = 16.0;\n  static const double paddingVertical = 16.0;\n  static const double paddingHorizontal = 16.0;\n  static const double borderWidth = 1.0;\n  static const double selectedBorderWidth = 2.0;\n  static const double iconSize = 16.0;\n\n  static const itemSpacing = 4.0;\n}\n\nclass FcnuiDefaultColor {\n  final BuildContext context;\n\n  FcnuiDefaultColor(this.context);\n\n  ThemeData get theme {\n    final ThemeVm themeVm =\n        ThemeVm.fromStore(fcnGetIt.get<Store<AppState>>(), context);\n    return themeVm.theme;\n  }\n\n  Color get borderColor => theme.dividerColor.withOpacity(.4);\n\n  Color get errorColor => Colors.red;\n\n  Color get greyColor => theme.colorScheme.onSurface.withOpacity(.5);\n}\n"
  }
]